<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Extending F# through Computation Expressions</title>
    <meta name="description" content="Explore patterns for extending the F# language using the computation expressions feature">
    <meta name="author" content="Ryan Riley">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="//code.jquery.com/jquery-1.8.0.js"></script>
    <script src="//code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">
    <link type="text/css" rel="stylesheet" href="fsharp.formatting/styles/style.css" />
    <link type="text/css" rel="stylesheet" href="fsharp.formatting/styles/deedle.css" />
    <link type="text/css" rel="stylesheet" href="css/custom.css" />
    <script src="fsharp.formatting/styles/tips.js" type="text/javascript"></script>
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link rel="stylesheet" href="css/fsreveal.css">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
    <script language="javascript" type="text/javascript">
        function init()
        {
            websocket = new WebSocket("ws://"+window.location.host+"/websocket");
            websocket.onmessage = function(evt) { location.reload(); };
        }
        window.addEventListener("load", init, false);
    </script>
</head>
<body>
    <div class="reveal">
        <div class="tip" id="fs1">namespace System</div>
<div class="tip" id="fs2">type Environment =<br />&#160;&#160;static member CommandLine : string<br />&#160;&#160;static member CurrentDirectory : string with get, set<br />&#160;&#160;static member CurrentManagedThreadId : int<br />&#160;&#160;static member Exit : exitCode:int -&gt; unit<br />&#160;&#160;static member ExitCode : int with get, set<br />&#160;&#160;static member ExpandEnvironmentVariables : name:string -&gt; string<br />&#160;&#160;static member FailFast : message:string -&gt; unit + 1 overload<br />&#160;&#160;static member GetCommandLineArgs : unit -&gt; string[]<br />&#160;&#160;static member GetEnvironmentVariable : variable:string -&gt; string + 1 overload<br />&#160;&#160;static member GetEnvironmentVariables : unit -&gt; IDictionary + 1 overload<br />&#160;&#160;...<br />&#160;&#160;nested type SpecialFolder<br />&#160;&#160;nested type SpecialFolderOption<br /><br />Full name: System.Environment</div>
<div class="tip" id="fs3">property System.Environment.CurrentDirectory: string</div>
<div class="tip" id="fs4">namespace System.Net</div>
<div class="tip" id="fs5">namespace System.Reactive</div>
<div class="tip" id="fs6">namespace System.Reactive.Linq</div>
<div class="tip" id="fs7">Multiple items<br />namespace FSharp<br /><br />--------------------<br />namespace Microsoft.FSharp</div>
<div class="tip" id="fs8">Multiple items<br />namespace FSharp.Control<br /><br />--------------------<br />namespace Microsoft.FSharp.Control</div>
<div class="tip" id="fs9">namespace FSharp.Control.Reactive</div>
<div class="tip" id="fs10">module Builders<br /><br />from FSharp.Control.Reactive</div>
<div class="tip" id="fs11">Multiple items<br />val seq : sequence:seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Core.Operators.seq<br /><br />--------------------<br />type seq&lt;&#39;T&gt; = Collections.Generic.IEnumerable&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.seq&lt;_&gt;</div>
<div class="tip" id="fs12">val i : int</div>
<div class="tip" id="fs13">val xs : seq&lt;int&gt;<br /><br />Full name: Index.xs</div>
<div class="tip" id="fs14">val ys : seq&lt;int&gt;<br /><br />Full name: Index.ys</div>
<div class="tip" id="fs15">val async : AsyncBuilder<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.async</div>
<div class="tip" id="fs16">val req : WebRequest</div>
<div class="tip" id="fs17">type WebRequest =<br />&#160;&#160;inherit MarshalByRefObject<br />&#160;&#160;member Abort : unit -&gt; unit<br />&#160;&#160;member AuthenticationLevel : AuthenticationLevel with get, set<br />&#160;&#160;member BeginGetRequestStream : callback:AsyncCallback * state:obj -&gt; IAsyncResult<br />&#160;&#160;member BeginGetResponse : callback:AsyncCallback * state:obj -&gt; IAsyncResult<br />&#160;&#160;member CachePolicy : RequestCachePolicy with get, set<br />&#160;&#160;member ConnectionGroupName : string with get, set<br />&#160;&#160;member ContentLength : int64 with get, set<br />&#160;&#160;member ContentType : string with get, set<br />&#160;&#160;member CreatorInstance : IWebRequestCreate<br />&#160;&#160;member Credentials : ICredentials with get, set<br />&#160;&#160;...<br /><br />Full name: System.Net.WebRequest</div>
<div class="tip" id="fs18">WebRequest.Create(requestUri: Uri) : WebRequest<br />WebRequest.Create(requestUriString: string) : WebRequest</div>
<div class="tip" id="fs19">val resp : WebResponse</div>
<div class="tip" id="fs20">member WebRequest.AsyncGetResponse : unit -&gt; Async&lt;WebResponse&gt;</div>
<div class="tip" id="fs21">val stream : IO.Stream</div>
<div class="tip" id="fs22">WebResponse.GetResponseStream() : IO.Stream</div>
<div class="tip" id="fs23">val bytes : byte []</div>
<div class="tip" id="fs24">member IO.Stream.AsyncRead : count:int -&gt; Async&lt;byte []&gt;<br />member IO.Stream.AsyncRead : buffer:byte [] * ?offset:int * ?count:int -&gt; Async&lt;int&gt;</div>
<div class="tip" id="fs25">val text : string</div>
<div class="tip" id="fs26">namespace System.Text</div>
<div class="tip" id="fs27">type Encoding =<br />&#160;&#160;member BodyName : string<br />&#160;&#160;member Clone : unit -&gt; obj<br />&#160;&#160;member CodePage : int<br />&#160;&#160;member DecoderFallback : DecoderFallback with get, set<br />&#160;&#160;member EncoderFallback : EncoderFallback with get, set<br />&#160;&#160;member EncodingName : string<br />&#160;&#160;member Equals : value:obj -&gt; bool<br />&#160;&#160;member GetByteCount : chars:char[] -&gt; int + 3 overloads<br />&#160;&#160;member GetBytes : chars:char[] -&gt; byte[] + 5 overloads<br />&#160;&#160;member GetCharCount : bytes:byte[] -&gt; int + 2 overloads<br />&#160;&#160;...<br /><br />Full name: System.Text.Encoding</div>
<div class="tip" id="fs28">property Text.Encoding.UTF8: Text.Encoding</div>
<div class="tip" id="fs29">Text.Encoding.GetString(bytes: byte []) : string<br />Text.Encoding.GetString(bytes: nativeptr&lt;byte&gt;, byteCount: int) : string<br />Text.Encoding.GetString(bytes: byte [], index: int, count: int) : string</div>
<div class="tip" id="fs30">type HttpWebResponse =<br />&#160;&#160;inherit WebResponse<br />&#160;&#160;member CharacterSet : string<br />&#160;&#160;member Close : unit -&gt; unit<br />&#160;&#160;member ContentEncoding : string<br />&#160;&#160;member ContentLength : int64<br />&#160;&#160;member ContentType : string<br />&#160;&#160;member Cookies : CookieCollection with get, set<br />&#160;&#160;member GetResponseHeader : headerName:string -&gt; string<br />&#160;&#160;member GetResponseStream : unit -&gt; Stream<br />&#160;&#160;member Headers : WebHeaderCollection<br />&#160;&#160;member IsMutuallyAuthenticated : bool<br />&#160;&#160;...<br /><br />Full name: System.Net.HttpWebResponse</div>
<div class="tip" id="fs31">Multiple items<br />type Async<br />static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; &#39;T) * (IAsyncResult -&gt; unit)<br />static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; Delegate)<br />static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member AwaitTask : task:Task -&gt; Async&lt;unit&gt;<br />static member AwaitTask : task:Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />static member AwaitWaitHandle : waitHandle:WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member CancelDefaultToken : unit -&gt; unit<br />static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;<br />static member Choice : computations:seq&lt;Async&lt;&#39;T option&gt;&gt; -&gt; Async&lt;&#39;T option&gt;<br />static member FromBeginEnd : beginAction:(AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg:&#39;Arg1 * beginAction:(&#39;Arg1 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * beginAction:(&#39;Arg1 * &#39;Arg2 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * arg3:&#39;Arg3 * beginAction:(&#39;Arg1 * &#39;Arg2 * &#39;Arg3 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member Ignore : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br />static member OnCancel : interruption:(unit -&gt; unit) -&gt; Async&lt;IDisposable&gt;<br />static member Parallel : computations:seq&lt;Async&lt;&#39;T&gt;&gt; -&gt; Async&lt;&#39;T []&gt;<br />static member RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:CancellationToken -&gt; &#39;T<br />static member Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;<br />static member Start : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions * ?cancellationToken:CancellationToken -&gt; Task&lt;&#39;T&gt;<br />static member StartChild : computation:Async&lt;&#39;T&gt; * ?millisecondsTimeout:int -&gt; Async&lt;Async&lt;&#39;T&gt;&gt;<br />static member StartChildAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions -&gt; Async&lt;Task&lt;&#39;T&gt;&gt;<br />static member StartImmediate : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartWithContinuations : computation:Async&lt;&#39;T&gt; * continuation:(&#39;T -&gt; unit) * exceptionContinuation:(exn -&gt; unit) * cancellationContinuation:(OperationCanceledException -&gt; unit) * ?cancellationToken:CancellationToken -&gt; unit<br />static member SwitchToContext : syncContext:SynchronizationContext -&gt; Async&lt;unit&gt;<br />static member SwitchToNewThread : unit -&gt; Async&lt;unit&gt;<br />static member SwitchToThreadPool : unit -&gt; Async&lt;unit&gt;<br />static member TryCancelled : computation:Async&lt;&#39;T&gt; * compensation:(OperationCanceledException -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member CancellationToken : Async&lt;CancellationToken&gt;<br />static member DefaultCancellationToken : CancellationToken<br /><br />Full name: Microsoft.FSharp.Control.Async<br /><br />--------------------<br />type Async&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Control.Async&lt;_&gt;</div>
<div class="tip" id="fs32">static member Async.RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:Threading.CancellationToken -&gt; &#39;T</div>
<div class="tip" id="fs33">Multiple items<br />type OptionMonad =<br />&#160;&#160;new : unit -&gt; OptionMonad<br />&#160;&#160;member Bind : m:&#39;b option * f:(&#39;b -&gt; &#39;c option) -&gt; &#39;c option<br />&#160;&#160;member Return : x:&#39;a -&gt; &#39;a option<br /><br />Full name: Index.OptionMonad<br /><br />--------------------<br />new : unit -&gt; OptionMonad</div>
<div class="tip" id="fs34">member OptionMonad.Bind : m:&#39;b option * f:(&#39;b -&gt; &#39;c option) -&gt; &#39;c option<br /><br />Full name: Index.OptionMonad.Bind</div>
<div class="tip" id="fs35">val m : &#39;b option</div>
<div class="tip" id="fs36">val f : (&#39;b -&gt; &#39;c option)</div>
<div class="tip" id="fs37">module Option<br /><br />from Microsoft.FSharp.Core</div>
<div class="tip" id="fs38">val bind : binder:(&#39;T -&gt; &#39;U option) -&gt; option:&#39;T option -&gt; &#39;U option<br /><br />Full name: Microsoft.FSharp.Core.Option.bind</div>
<div class="tip" id="fs39">val __ : OptionMonad</div>
<div class="tip" id="fs40">member OptionMonad.Return : x:&#39;a -&gt; &#39;a option<br /><br />Full name: Index.OptionMonad.Return</div>
<div class="tip" id="fs41">val x : &#39;a</div>
<div class="tip" id="fs42">union case Option.Some: Value: &#39;T -&gt; Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs43">val opt : OptionMonad<br /><br />Full name: Index.opt</div>
<div class="tip" id="fs44">Multiple items<br />type OptionBuilder =<br />&#160;&#160;new : unit -&gt; OptionBuilder<br />&#160;&#160;member Bind : m:&#39;d option * f:(&#39;d -&gt; &#39;e option) -&gt; &#39;e option<br />&#160;&#160;member Combine : m:unit option * f:(unit -&gt; &#39;b option) -&gt; &#39;b option<br />&#160;&#160;member Delay : f:(unit -&gt; &#39;T) -&gt; (unit -&gt; &#39;T)<br />&#160;&#160;member Return : x:&#39;c -&gt; &#39;c option<br />&#160;&#160;member ReturnFrom : m:&#39;T option -&gt; &#39;T option<br />&#160;&#160;member Run : f:(unit -&gt; &#39;a) -&gt; &#39;a<br />&#160;&#160;member Zero : unit -&gt; unit option<br /><br />Full name: Index.OptionBuilder<br /><br />--------------------<br />new : unit -&gt; OptionBuilder</div>
<div class="tip" id="fs45">member OptionBuilder.Bind : m:&#39;d option * f:(&#39;d -&gt; &#39;e option) -&gt; &#39;e option<br /><br />Full name: Index.OptionBuilder.Bind</div>
<div class="tip" id="fs46">val m : &#39;d option</div>
<div class="tip" id="fs47">val f : (&#39;d -&gt; &#39;e option)</div>
<div class="tip" id="fs48">val __ : OptionBuilder</div>
<div class="tip" id="fs49">member OptionBuilder.Return : x:&#39;c -&gt; &#39;c option<br /><br />Full name: Index.OptionBuilder.Return</div>
<div class="tip" id="fs50">val x : &#39;c</div>
<div class="tip" id="fs51">member OptionBuilder.ReturnFrom : m:&#39;T option -&gt; &#39;T option<br /><br />Full name: Index.OptionBuilder.ReturnFrom</div>
<div class="tip" id="fs52">val m : &#39;T option</div>
<div class="tip" id="fs53">type &#39;T option = Option&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Core.option&lt;_&gt;</div>
<div class="tip" id="fs54">member OptionBuilder.Zero : unit -&gt; unit option<br /><br />Full name: Index.OptionBuilder.Zero</div>
<div class="tip" id="fs55">member OptionBuilder.Combine : m:unit option * f:(unit -&gt; &#39;b option) -&gt; &#39;b option<br /><br />Full name: Index.OptionBuilder.Combine</div>
<div class="tip" id="fs56">val m : unit option</div>
<div class="tip" id="fs57">val f : (unit -&gt; &#39;b option)</div>
<div class="tip" id="fs58">type unit = Unit<br /><br />Full name: Microsoft.FSharp.Core.unit</div>
<div class="tip" id="fs59">member OptionBuilder.Delay : f:(unit -&gt; &#39;T) -&gt; (unit -&gt; &#39;T)<br /><br />Full name: Index.OptionBuilder.Delay</div>
<div class="tip" id="fs60">val f : (unit -&gt; &#39;T)</div>
<div class="tip" id="fs61">member OptionBuilder.Run : f:(unit -&gt; &#39;a) -&gt; &#39;a<br /><br />Full name: Index.OptionBuilder.Run</div>
<div class="tip" id="fs62">val f : (unit -&gt; &#39;a)</div>
<div class="tip" id="fs63">val maybe : OptionBuilder<br /><br />Full name: Index.maybe</div>
<div class="tip" id="fs64">val one : int option<br /><br />Full name: Index.one</div>
<div class="tip" id="fs65">Multiple items<br />val double : x:int -&gt; int option<br /><br />Full name: Index.double<br /><br />--------------------<br />type double = Double<br /><br />Full name: Microsoft.FSharp.Core.double</div>
<div class="tip" id="fs66">val x : int</div>
<div class="tip" id="fs67">val carryOn : bool<br /><br />Full name: Index.carryOn</div>
<div class="tip" id="fs68">val printfn : format:Printf.TextWriterFormat&lt;&#39;T&gt; -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.printfn</div>
<div class="tip" id="fs69">val y : int</div>
<div class="tip" id="fs70">union case Option.None: Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs71">val query : Linq.QueryBuilder<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.query</div>
<div class="tip" id="fs72">custom operation: where (bool)<br /><br />Calls Linq.QueryBuilder.Where </div>
<div class="tip" id="fs73">custom operation: select (&#39;Result)<br /><br />Calls Linq.QueryBuilder.Select </div>
<div class="tip" id="fs74">val rxquery : RxQueryBuilder<br /><br />Full name: FSharp.Control.Reactive.Builders.rxquery</div>
<div class="tip" id="fs75">type Observable =<br />&#160;&#160;static member Aggregate&lt;&#39;TSource&gt; : source:IObservable&lt;&#39;TSource&gt; * accumulator:Func&lt;&#39;TSource, &#39;TSource, &#39;TSource&gt; -&gt; IObservable&lt;&#39;TSource&gt; + 2 overloads<br />&#160;&#160;static member All&lt;&#39;TSource&gt; : source:IObservable&lt;&#39;TSource&gt; * predicate:Func&lt;&#39;TSource, bool&gt; -&gt; IObservable&lt;bool&gt;<br />&#160;&#160;static member Amb&lt;&#39;TSource&gt; : [&lt;ParamArray&gt;] sources:IObservable&lt;&#39;TSource&gt;[] -&gt; IObservable&lt;&#39;TSource&gt; + 2 overloads<br />&#160;&#160;static member And&lt;&#39;TLeft, &#39;TRight&gt; : left:IObservable&lt;&#39;TLeft&gt; * right:IObservable&lt;&#39;TRight&gt; -&gt; Pattern&lt;&#39;TLeft, &#39;TRight&gt;<br />&#160;&#160;static member Any&lt;&#39;TSource&gt; : source:IObservable&lt;&#39;TSource&gt; -&gt; IObservable&lt;bool&gt; + 1 overload<br />&#160;&#160;static member AsObservable&lt;&#39;TSource&gt; : source:IObservable&lt;&#39;TSource&gt; -&gt; IObservable&lt;&#39;TSource&gt;<br />&#160;&#160;static member Average : source:IObservable&lt;float&gt; -&gt; IObservable&lt;float&gt; + 19 overloads<br />&#160;&#160;static member Buffer&lt;&#39;TSource, &#39;TBufferClosing&gt; : source:IObservable&lt;&#39;TSource&gt; * bufferClosingSelector:Func&lt;IObservable&lt;&#39;TBufferClosing&gt;&gt; -&gt; IObservable&lt;IList&lt;&#39;TSource&gt;&gt; + 10 overloads<br />&#160;&#160;static member Case&lt;&#39;TValue, &#39;TResult&gt; : selector:Func&lt;&#39;TValue&gt; * sources:IDictionary&lt;&#39;TValue, IObservable&lt;&#39;TResult&gt;&gt; -&gt; IObservable&lt;&#39;TResult&gt; + 2 overloads<br />&#160;&#160;static member Cast&lt;&#39;TResult&gt; : source:IObservable&lt;obj&gt; -&gt; IObservable&lt;&#39;TResult&gt;<br />&#160;&#160;...<br /><br />Full name: System.Reactive.Linq.Observable</div>
<div class="tip" id="fs76">val ofSeq : items:seq&lt;&#39;Item&gt; -&gt; IObservable&lt;&#39;Item&gt;<br /><br />Full name: FSharp.Control.Reactive.Observable.ofSeq</div>
<div class="tip" id="fs77">custom operation: zip var in collection<br /><br />Calls RxQueryBuilder.Zip </div>
<div class="tip" id="fs78">custom operation: select (&#39;b)<br /><br />Calls RxQueryBuilder.Select </div>
<div class="tip" id="fs79">Multiple items<br />val subscribe : onNext:(&#39;T -&gt; unit) -&gt; observable:IObservable&lt;&#39;T&gt; -&gt; IDisposable<br /><br />Full name: FSharp.Control.Reactive.Observable.subscribe<br /><br />--------------------<br />val subscribe : callback:(&#39;T -&gt; unit) -&gt; source:IObservable&lt;&#39;T&gt; -&gt; IDisposable<br /><br />Full name: Microsoft.FSharp.Control.Observable.subscribe</div>
<div class="tip" id="fs80">Multiple items<br />type RxQueryBuilder =<br />&#160;&#160;new : unit -&gt; RxQueryBuilder<br />&#160;&#160;member All : s:IObservable&lt;&#39;a0&gt; * predicate:(&#39;a0 -&gt; bool) -&gt; IObservable&lt;bool&gt;<br />&#160;&#160;member Contains : s:IObservable&lt;&#39;a0&gt; * key:&#39;a0 -&gt; IObservable&lt;bool&gt;<br />&#160;&#160;member Count : s:IObservable&lt;&#39;a0&gt; -&gt; IObservable&lt;int&gt;<br />&#160;&#160;member Distinct : s:IObservable&lt;&#39;a0&gt; -&gt; IObservable&lt;&#39;a0&gt;<br />&#160;&#160;member ExactlyOne : s:IObservable&lt;&#39;a0&gt; -&gt; IObservable&lt;&#39;a0&gt;<br />&#160;&#160;member ExactlyOneOrDefault : s:IObservable&lt;&#39;a0&gt; -&gt; IObservable&lt;&#39;a0&gt;<br />&#160;&#160;member Find : s:IObservable&lt;&#39;a0&gt; * predicate:(&#39;a0 -&gt; bool) -&gt; IObservable&lt;&#39;a0&gt;<br />&#160;&#160;member For : s:IObservable&lt;&#39;a&gt; * body:(&#39;a -&gt; IObservable&lt;&#39;b&gt;) -&gt; IObservable&lt;&#39;b&gt;<br />&#160;&#160;member GroupBy : s:IObservable&lt;&#39;a0&gt; * keySelector:(&#39;a0 -&gt; &#39;a1) -&gt; IObservable&lt;IGroupedObservable&lt;&#39;a1,&#39;a0&gt;&gt;<br />&#160;&#160;...<br /><br />Full name: FSharp.Control.Reactive.BuildersModule.RxQueryBuilder<br /><br />--------------------<br />new : unit -&gt; RxQueryBuilder</div>
<div class="tip" id="fs81">Multiple items<br />type CustomOperationAttribute =<br />&#160;&#160;inherit Attribute<br />&#160;&#160;new : name:string -&gt; CustomOperationAttribute<br />&#160;&#160;member AllowIntoPattern : bool<br />&#160;&#160;member IsLikeGroupJoin : bool<br />&#160;&#160;member IsLikeJoin : bool<br />&#160;&#160;member IsLikeZip : bool<br />&#160;&#160;member JoinConditionWord : string<br />&#160;&#160;member MaintainsVariableSpace : bool<br />&#160;&#160;member MaintainsVariableSpaceUsingBind : bool<br />&#160;&#160;member Name : string<br />&#160;&#160;...<br /><br />Full name: Microsoft.FSharp.Core.CustomOperationAttribute<br /><br />--------------------<br />new : name:string -&gt; CustomOperationAttribute</div>
<div class="tip" id="fs82">member RxQueryBuilder.Select : s:IObservable&lt;&#39;a&gt; * selector:(&#39;a -&gt; &#39;b) -&gt; IObservable&lt;&#39;b&gt;<br /><br />Full name: Index.Select</div>
<div class="tip" id="fs83">val s : IObservable&lt;&#39;a&gt;</div>
<div class="tip" id="fs84">type IObservable&lt;&#39;T&gt; =<br />&#160;&#160;member Subscribe : observer:IObserver&lt;&#39;T&gt; -&gt; IDisposable<br /><br />Full name: System.IObservable&lt;_&gt;</div>
<div class="tip" id="fs85">Multiple items<br />type ProjectionParameterAttribute =<br />&#160;&#160;inherit Attribute<br />&#160;&#160;new : unit -&gt; ProjectionParameterAttribute<br /><br />Full name: Microsoft.FSharp.Core.ProjectionParameterAttribute<br /><br />--------------------<br />new : unit -&gt; ProjectionParameterAttribute</div>
<div class="tip" id="fs86">val selector : (&#39;a -&gt; &#39;b)</div>
<div class="tip" id="fs87">(extension) IObservable.Select&lt;&#39;TSource,&#39;TResult&gt;(selector: Func&lt;&#39;TSource,&#39;TResult&gt;) : IObservable&lt;&#39;TResult&gt;<br />(extension) IObservable.Select&lt;&#39;TSource,&#39;TResult&gt;(selector: Func&lt;&#39;TSource,int,&#39;TResult&gt;) : IObservable&lt;&#39;TResult&gt;</div>
<div class="tip" id="fs88">val __ : RxQueryBuilder</div>
<div class="tip" id="fs89">member RxQueryBuilder.Zip : s1:IObservable&lt;&#39;a&gt; * s2:IObservable&lt;&#39;b&gt; * resultSelector:(&#39;a -&gt; &#39;b -&gt; &#39;c) -&gt; IObservable&lt;&#39;c&gt;<br /><br />Full name: Index.Zip</div>
<div class="tip" id="fs90">val s1 : IObservable&lt;&#39;a&gt;</div>
<div class="tip" id="fs91">val s2 : IObservable&lt;&#39;b&gt;</div>
<div class="tip" id="fs92">val resultSelector : (&#39;a -&gt; &#39;b -&gt; &#39;c)</div>
<div class="tip" id="fs93">(extension) IObservable.Zip&lt;&#39;TSource1,&#39;TSource2,&#39;TResult&gt;(second: IObservable&lt;&#39;TSource2&gt;, resultSelector: Func&lt;&#39;TSource1,&#39;TSource2,&#39;TResult&gt;) : IObservable&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />(extension) IObservable.Zip&lt;&#39;TSource1,&#39;TSource2,&#39;TResult&gt;(second: Collections.Generic.IEnumerable&lt;&#39;TSource2&gt;, resultSelector: Func&lt;&#39;TSource1,&#39;TSource2,&#39;TResult&gt;) : IObservable&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />(extension) IObservable.Zip&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TResult&gt;(source2: IObservable&lt;&#39;TSource2&gt;, source3: IObservable&lt;&#39;TSource3&gt;, resultSelector: Func&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TResult&gt;) : IObservable&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />(extension) IObservable.Zip&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TResult&gt;(source2: IObservable&lt;&#39;TSource2&gt;, source3: IObservable&lt;&#39;TSource3&gt;, source4: IObservable&lt;&#39;TSource4&gt;, resultSelector: Func&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TResult&gt;) : IObservable&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />(extension) IObservable.Zip&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TSource5,&#39;TResult&gt;(source2: IObservable&lt;&#39;TSource2&gt;, source3: IObservable&lt;&#39;TSource3&gt;, source4: IObservable&lt;&#39;TSource4&gt;, source5: IObservable&lt;&#39;TSource5&gt;, resultSelector: Func&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TSource5,&#39;TResult&gt;) : IObservable&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />(extension) IObservable.Zip&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TSource5,&#39;TSource6,&#39;TResult&gt;(source2: IObservable&lt;&#39;TSource2&gt;, source3: IObservable&lt;&#39;TSource3&gt;, source4: IObservable&lt;&#39;TSource4&gt;, source5: IObservable&lt;&#39;TSource5&gt;, source6: IObservable&lt;&#39;TSource6&gt;, resultSelector: Func&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TSource5,&#39;TSource6,&#39;TResult&gt;) : IObservable&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />(extension) IObservable.Zip&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TSource5,&#39;TSource6,&#39;TSource7,&#39;TResult&gt;(source2: IObservable&lt;&#39;TSource2&gt;, source3: IObservable&lt;&#39;TSource3&gt;, source4: IObservable&lt;&#39;TSource4&gt;, source5: IObservable&lt;&#39;TSource5&gt;, source6: IObservable&lt;&#39;TSource6&gt;, source7: IObservable&lt;&#39;TSource7&gt;, resultSelector: Func&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TSource5,&#39;TSource6,&#39;TSource7,&#39;TResult&gt;) : IObservable&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />(extension) IObservable.Zip&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TSource5,&#39;TSource6,&#39;TSource7,&#39;TSource8,&#39;TResult&gt;(source2: IObservable&lt;&#39;TSource2&gt;, source3: IObservable&lt;&#39;TSource3&gt;, source4: IObservable&lt;&#39;TSource4&gt;, source5: IObservable&lt;&#39;TSource5&gt;, source6: IObservable&lt;&#39;TSource6&gt;, source7: IObservable&lt;&#39;TSource7&gt;, source8: IObservable&lt;&#39;TSource8&gt;, resultSelector: Func&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TSource5,&#39;TSource6,&#39;TSource7,&#39;TSource8,&#39;TResult&gt;) : IObservable&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />(extension) IObservable.Zip&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TSource5,&#39;TSource6,&#39;TSource7,&#39;TSource8,&#39;TSource9,&#39;TResult&gt;(source2: IObservable&lt;&#39;TSource2&gt;, source3: IObservable&lt;&#39;TSource3&gt;, source4: IObservable&lt;&#39;TSource4&gt;, source5: IObservable&lt;&#39;TSource5&gt;, source6: IObservable&lt;&#39;TSource6&gt;, source7: IObservable&lt;&#39;TSource7&gt;, source8: IObservable&lt;&#39;TSource8&gt;, source9: IObservable&lt;&#39;TSource9&gt;, resultSelector: Func&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TSource5,&#39;TSource6,&#39;TSource7,&#39;TSource8,&#39;TSource9,&#39;TResult&gt;) : IObservable&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />(extension) IObservable.Zip&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TSource5,&#39;TSource6,&#39;TSource7,&#39;TSource8,&#39;TSource9,&#39;TSource10,&#39;TResult&gt;(source2: IObservable&lt;&#39;TSource2&gt;, source3: IObservable&lt;&#39;TSource3&gt;, source4: IObservable&lt;&#39;TSource4&gt;, source5: IObservable&lt;&#39;TSource5&gt;, source6: IObservable&lt;&#39;TSource6&gt;, source7: IObservable&lt;&#39;TSource7&gt;, source8: IObservable&lt;&#39;TSource8&gt;, source9: IObservable&lt;&#39;TSource9&gt;, source10: IObservable&lt;&#39;TSource10&gt;, resultSelector: Func&lt;&#39;TSource1,&#39;TSource2,&#39;TSource3,&#39;TSource4,&#39;TSource5,&#39;TSource6,&#39;TSource7,&#39;TSource8,&#39;TSource9,&#39;TSource10,&#39;TResult&gt;) : IObservable&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em></div>
<div class="tip" id="fs94">Multiple items<br />type Func&lt;&#39;TResult&gt; =<br />&#160;&#160;delegate of unit -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;T5,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 * &#39;T5 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;T5,&#39;T6,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 * &#39;T5 * &#39;T6 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;T5,&#39;T6,&#39;T7,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 * &#39;T5 * &#39;T6 * &#39;T7 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;T5,&#39;T6,&#39;T7,&#39;T8,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 * &#39;T5 * &#39;T6 * &#39;T7 * &#39;T8 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_,_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;T5,&#39;T6,&#39;T7,&#39;T8,&#39;T9,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 * &#39;T5 * &#39;T6 * &#39;T7 * &#39;T8 * &#39;T9 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_,_,_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;T5,&#39;T6,&#39;T7,&#39;T8,&#39;T9,&#39;T10,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 * &#39;T5 * &#39;T6 * &#39;T7 * &#39;T8 * &#39;T9 * &#39;T10 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_,_,_,_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;T5,&#39;T6,&#39;T7,&#39;T8,&#39;T9,&#39;T10,&#39;T11,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 * &#39;T5 * &#39;T6 * &#39;T7 * &#39;T8 * &#39;T9 * &#39;T10 * &#39;T11 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_,_,_,_,_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;T5,&#39;T6,&#39;T7,&#39;T8,&#39;T9,&#39;T10,&#39;T11,&#39;T12,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 * &#39;T5 * &#39;T6 * &#39;T7 * &#39;T8 * &#39;T9 * &#39;T10 * &#39;T11 * &#39;T12 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_,_,_,_,_,_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;T5,&#39;T6,&#39;T7,&#39;T8,&#39;T9,&#39;T10,&#39;T11,&#39;T12,&#39;T13,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 * &#39;T5 * &#39;T6 * &#39;T7 * &#39;T8 * &#39;T9 * &#39;T10 * &#39;T11 * &#39;T12 * &#39;T13 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_,_,_,_,_,_,_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;T5,&#39;T6,&#39;T7,&#39;T8,&#39;T9,&#39;T10,&#39;T11,&#39;T12,&#39;T13,&#39;T14,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 * &#39;T5 * &#39;T6 * &#39;T7 * &#39;T8 * &#39;T9 * &#39;T10 * &#39;T11 * &#39;T12 * &#39;T13 * &#39;T14 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_,_,_,_,_,_,_,_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;T5,&#39;T6,&#39;T7,&#39;T8,&#39;T9,&#39;T10,&#39;T11,&#39;T12,&#39;T13,&#39;T14,&#39;T15,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 * &#39;T5 * &#39;T6 * &#39;T7 * &#39;T8 * &#39;T9 * &#39;T10 * &#39;T11 * &#39;T12 * &#39;T13 * &#39;T14 * &#39;T15 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_&gt;<br /><br />--------------------<br />type Func&lt;&#39;T1,&#39;T2,&#39;T3,&#39;T4,&#39;T5,&#39;T6,&#39;T7,&#39;T8,&#39;T9,&#39;T10,&#39;T11,&#39;T12,&#39;T13,&#39;T14,&#39;T15,&#39;T16,&#39;TResult&gt; =<br />&#160;&#160;delegate of &#39;T1 * &#39;T2 * &#39;T3 * &#39;T4 * &#39;T5 * &#39;T6 * &#39;T7 * &#39;T8 * &#39;T9 * &#39;T10 * &#39;T11 * &#39;T12 * &#39;T13 * &#39;T14 * &#39;T15 * &#39;T16 -&gt; &#39;TResult<br /><br />Full name: System.Func&lt;_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_&gt;</div>
<div class="tip" id="fs95">type AsyncBuilder =<br />&#160;&#160;private new : unit -&gt; AsyncBuilder<br />&#160;&#160;member Bind : computation:Async&lt;&#39;T&gt; * binder:(&#39;T -&gt; Async&lt;&#39;U&gt;) -&gt; Async&lt;&#39;U&gt;<br />&#160;&#160;member Combine : computation1:Async&lt;unit&gt; * computation2:Async&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;member Delay : generator:(unit -&gt; Async&lt;&#39;T&gt;) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;member For : sequence:seq&lt;&#39;T&gt; * body:(&#39;T -&gt; Async&lt;unit&gt;) -&gt; Async&lt;unit&gt;<br />&#160;&#160;member Return : value:&#39;T -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;member ReturnFrom : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;member TryFinally : computation:Async&lt;&#39;T&gt; * compensation:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;member TryWith : computation:Async&lt;&#39;T&gt; * catchHandler:(exn -&gt; Async&lt;&#39;T&gt;) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;member Using : resource:&#39;T * binder:(&#39;T -&gt; Async&lt;&#39;U&gt;) -&gt; Async&lt;&#39;U&gt; (requires &#39;T :&gt; IDisposable)<br />&#160;&#160;...<br /><br />Full name: Microsoft.FSharp.Control.AsyncBuilder</div>
<div class="tip" id="fs96">member AsyncBuilder.Merge : x:Async&lt;&#39;a&gt; * y:Async&lt;&#39;b&gt; * f:(&#39;a -&gt; &#39;b -&gt; &#39;c) -&gt; Async&lt;&#39;c&gt;<br /><br />Full name: Index.Merge</div>
<div class="tip" id="fs97">val x : Async&lt;&#39;a&gt;</div>
<div class="tip" id="fs98">val y : Async&lt;&#39;b&gt;</div>
<div class="tip" id="fs99">val f : (&#39;a -&gt; &#39;b -&gt; &#39;c)</div>
<div class="tip" id="fs100">val token : Threading.CancellationToken</div>
<div class="tip" id="fs101">property Async.CancellationToken: Async&lt;Threading.CancellationToken&gt;</div>
<div class="tip" id="fs102">val x&#39; : Threading.Tasks.Task&lt;&#39;a&gt;</div>
<div class="tip" id="fs103">static member Async.StartChildAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:Threading.Tasks.TaskCreationOptions -&gt; Async&lt;Threading.Tasks.Task&lt;&#39;T&gt;&gt;</div>
<div class="tip" id="fs104">val y&#39; : Threading.Tasks.Task&lt;&#39;b&gt;</div>
<div class="tip" id="fs105">namespace System.Threading</div>
<div class="tip" id="fs106">namespace System.Threading.Tasks</div>
<div class="tip" id="fs107">Multiple items<br />type Task&lt;&#39;TResult&gt; =<br />&#160;&#160;inherit Task<br />&#160;&#160;new : function:Func&lt;&#39;TResult&gt; -&gt; Task&lt;&#39;TResult&gt; + 7 overloads<br />&#160;&#160;member ConfigureAwait : continueOnCapturedContext:bool -&gt; ConfiguredTaskAwaitable&lt;&#39;TResult&gt;<br />&#160;&#160;member ContinueWith : continuationAction:Action&lt;Task&lt;&#39;TResult&gt;&gt; -&gt; Task + 19 overloads<br />&#160;&#160;member GetAwaiter : unit -&gt; TaskAwaiter&lt;&#39;TResult&gt;<br />&#160;&#160;member Result : &#39;TResult<br />&#160;&#160;static member Factory : TaskFactory&lt;&#39;TResult&gt;<br /><br />Full name: System.Threading.Tasks.Task&lt;_&gt;<br /><br />--------------------<br />type Task =<br />&#160;&#160;new : action:Action -&gt; Task + 7 overloads<br />&#160;&#160;member AsyncState : obj<br />&#160;&#160;member ConfigureAwait : continueOnCapturedContext:bool -&gt; ConfiguredTaskAwaitable<br />&#160;&#160;member ContinueWith : continuationAction:Action&lt;Task&gt; -&gt; Task + 19 overloads<br />&#160;&#160;member CreationOptions : TaskCreationOptions<br />&#160;&#160;member Dispose : unit -&gt; unit<br />&#160;&#160;member Exception : AggregateException<br />&#160;&#160;member GetAwaiter : unit -&gt; TaskAwaiter<br />&#160;&#160;member Id : int<br />&#160;&#160;member IsCanceled : bool<br />&#160;&#160;...<br /><br />Full name: System.Threading.Tasks.Task<br /><br />--------------------<br />Threading.Tasks.Task(function: Func&lt;&#39;TResult&gt;) : unit<br />Threading.Tasks.Task(function: Func&lt;&#39;TResult&gt;, cancellationToken: Threading.CancellationToken) : unit<br />Threading.Tasks.Task(function: Func&lt;&#39;TResult&gt;, creationOptions: Threading.Tasks.TaskCreationOptions) : unit<br />Threading.Tasks.Task(function: Func&lt;obj,&#39;TResult&gt;, state: obj) : unit<br />Threading.Tasks.Task(function: Func&lt;&#39;TResult&gt;, cancellationToken: Threading.CancellationToken, creationOptions: Threading.Tasks.TaskCreationOptions) : unit<br />Threading.Tasks.Task(function: Func&lt;obj,&#39;TResult&gt;, state: obj, cancellationToken: Threading.CancellationToken) : unit<br />Threading.Tasks.Task(function: Func&lt;obj,&#39;TResult&gt;, state: obj, creationOptions: Threading.Tasks.TaskCreationOptions) : unit<br />Threading.Tasks.Task(function: Func&lt;obj,&#39;TResult&gt;, state: obj, cancellationToken: Threading.CancellationToken, creationOptions: Threading.Tasks.TaskCreationOptions) : unit<br /><br />--------------------<br />Threading.Tasks.Task(action: Action) : unit<br />Threading.Tasks.Task(action: Action, cancellationToken: Threading.CancellationToken) : unit<br />Threading.Tasks.Task(action: Action, creationOptions: Threading.Tasks.TaskCreationOptions) : unit<br />Threading.Tasks.Task(action: Action&lt;obj&gt;, state: obj) : unit<br />Threading.Tasks.Task(action: Action, cancellationToken: Threading.CancellationToken, creationOptions: Threading.Tasks.TaskCreationOptions) : unit<br />Threading.Tasks.Task(action: Action&lt;obj&gt;, state: obj, cancellationToken: Threading.CancellationToken) : unit<br />Threading.Tasks.Task(action: Action&lt;obj&gt;, state: obj, creationOptions: Threading.Tasks.TaskCreationOptions) : unit<br />Threading.Tasks.Task(action: Action&lt;obj&gt;, state: obj, cancellationToken: Threading.CancellationToken, creationOptions: Threading.Tasks.TaskCreationOptions) : unit</div>
<div class="tip" id="fs108">Threading.Tasks.Task.WaitAll([&lt;ParamArray&gt;] tasks: Threading.Tasks.Task []) : unit<br />Threading.Tasks.Task.WaitAll(tasks: Threading.Tasks.Task [], cancellationToken: Threading.CancellationToken) : unit<br />Threading.Tasks.Task.WaitAll(tasks: Threading.Tasks.Task [], millisecondsTimeout: int) : bool<br />Threading.Tasks.Task.WaitAll(tasks: Threading.Tasks.Task [], timeout: TimeSpan) : bool<br />Threading.Tasks.Task.WaitAll(tasks: Threading.Tasks.Task [], millisecondsTimeout: int, cancellationToken: Threading.CancellationToken) : bool</div>
<div class="tip" id="fs109">val x&#39;&#39; : &#39;a</div>
<div class="tip" id="fs110">static member Async.AwaitTask : task:Threading.Tasks.Task -&gt; Async&lt;unit&gt;<br />static member Async.AwaitTask : task:Threading.Tasks.Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;</div>
<div class="tip" id="fs111">val y&#39;&#39; : &#39;b</div>
<div class="tip" id="fs112">val __ : AsyncBuilder</div>
<div class="tip" id="fs113">member AsyncBuilder.For : m:Async&lt;&#39;a&gt; * f:(&#39;a -&gt; Async&lt;&#39;b&gt;) -&gt; Async&lt;&#39;b&gt;<br /><br />Full name: Index.For</div>
<div class="tip" id="fs114">val m : Async&lt;&#39;a&gt;</div>
<div class="tip" id="fs115">val f : (&#39;a -&gt; Async&lt;&#39;b&gt;)</div>
<div class="tip" id="fs116">member AsyncBuilder.Bind : computation:Async&lt;&#39;T&gt; * binder:(&#39;T -&gt; Async&lt;&#39;U&gt;) -&gt; Async&lt;&#39;U&gt;</div>
<div class="tip" id="fs117">val a : sw:Diagnostics.Stopwatch -&gt; Async&lt;int&gt;<br /><br />Full name: Index.a</div>
<div class="tip" id="fs118">val sw : Diagnostics.Stopwatch</div>
<div class="tip" id="fs119">namespace System.Diagnostics</div>
<div class="tip" id="fs120">Multiple items<br />type Stopwatch =<br />&#160;&#160;new : unit -&gt; Stopwatch<br />&#160;&#160;member Elapsed : TimeSpan<br />&#160;&#160;member ElapsedMilliseconds : int64<br />&#160;&#160;member ElapsedTicks : int64<br />&#160;&#160;member IsRunning : bool<br />&#160;&#160;member Reset : unit -&gt; unit<br />&#160;&#160;member Restart : unit -&gt; unit<br />&#160;&#160;member Start : unit -&gt; unit<br />&#160;&#160;member Stop : unit -&gt; unit<br />&#160;&#160;static val Frequency : int64<br />&#160;&#160;...<br /><br />Full name: System.Diagnostics.Stopwatch<br /><br />--------------------<br />Diagnostics.Stopwatch() : unit</div>
<div class="tip" id="fs121">property Diagnostics.Stopwatch.ElapsedMilliseconds: int64</div>
<div class="tip" id="fs122">static member Async.Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;</div>
<div class="tip" id="fs123">val b : sw:Diagnostics.Stopwatch -&gt; Async&lt;int&gt;<br /><br />Full name: Index.b</div>
<div class="tip" id="fs124">val comp : sw:Diagnostics.Stopwatch -&gt; Async&lt;int&gt;<br /><br />Full name: Index.comp</div>
<div class="tip" id="fs125">val compBind : sw:Diagnostics.Stopwatch -&gt; Async&lt;int&gt;<br /><br />Full name: Index.compBind</div>
<div class="tip" id="fs126">val sw : Diagnostics.Stopwatch<br /><br />Full name: Index.sw</div>
<div class="tip" id="fs127">Diagnostics.Stopwatch.StartNew() : Diagnostics.Stopwatch</div>
<div class="tip" id="fs128">val result : int<br /><br />Full name: Index.result</div>
<div class="tip" id="fs129">Diagnostics.Stopwatch.Stop() : unit</div>
<div class="tip" id="fs130">Diagnostics.Stopwatch.Reset() : unit</div>
<div class="tip" id="fs131">Diagnostics.Stopwatch.Start() : unit</div>
<div class="tip" id="fs132">val resultBind : int<br /><br />Full name: Index.resultBind</div>
<div class="tip" id="fs133">val c : sw:Diagnostics.Stopwatch -&gt; Async&lt;int&gt;<br /><br />Full name: Index.c</div>
<div class="tip" id="fs134">val comp3 : sw:Diagnostics.Stopwatch -&gt; Async&lt;int&gt;<br /><br />Full name: Index.comp3</div>
<div class="tip" id="fs135">val z : int</div>
<div class="tip" id="fs136">val result3 : int<br /><br />Full name: Index.result3</div>

        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section >
<h2>Extending F# through Computation Expressions</h2>
<h3>Ryan Riley</h3>
</section>
<section >
<h2>Prerequisites</h2>
<aside class="notes">
This is a somewhat advanced level talk in that I assume<br/>
you know or are familiar with a few of the more advanced<br/>
aspects of F# or similar languages, including:<br/>
- how to write a computation expression<br/>
- monoids, monads, applicatives, etc.<br/>
- statically resolved type parameters<br/>
- .NET method overloading<br/>
</aside>
</section>
<section >
<h2>Motivation</h2>
<aside class="notes">
One of the goals of this conference was to not dive into<br/>
language features for their own sake. I don't intend to<br/>
just tell you about computation expressions, nor do I intend<br/>
to cover the academic aspects, which you can find in other<br/>
talks and papers.<br/>
I want to convey the power of computation expressions as they<br/>
related to solving problems. What sorts of problems? I hope<br/>
to show computation expressions are useful for solving many<br/>
different types of problems, as many as may be solved by<br/>
writing computer programs.<br/>
That seems quite broad, and I agree. It's quite possible that<br/>
computation expressions are really just a fancy way to do<br/>
what we already do in F# or any other language, but I'll leave<br/>
you to decide that at the end. I hope to show you that, at the<br/>
very least, computation expressions can offer a useful model<br/>
for writing correct programs for a given domain.<br/>
</aside>
</section>
<section >
<h2>Examples</h2>
<aside class="notes">
Let's begin with a few examples built into the language.<br/>
</aside>
</section>
<section >
<h3>Seq<'T></h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs11', 19)" onmouseover="showTip(event, 'fs11', 19)" class="i">seq</span> {
    <span class="k">for</span> <span onmouseout="hideTip(event, 'fs12', 20)" onmouseover="showTip(event, 'fs12', 20)" class="i">i</span> <span class="k">in</span> <span class="n">1..</span><span class="n">10</span> <span class="k">do</span>
    <span class="k">yield</span> <span onmouseout="hideTip(event, 'fs12', 21)" onmouseover="showTip(event, 'fs12', 21)" class="i">i</span>
}
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>seq [1; 2; 3; 4; ...]</code></pre></td></tr></table>
<aside class="notes">
F# has several list-like comprehensions, including list,<br/>
array, and seq. Here I've chosen to show seq since it looks<br/>
the most like the standard computation expression syntax.<br/>
It's worth noting that there are several seq-related<br/>
optimizations built into the compiler (according to Dave Thomas)<br/>
that are not available to normal computation expressions,<br/>
but this serves as a useful example for the list-like<br/>
syntax.<br/>
</aside>
</section>
<section >
<h3>Concatenating Seq<'T></h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs13', 22)" onmouseover="showTip(event, 'fs13', 22)" class="i">xs</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs11', 23)" onmouseover="showTip(event, 'fs11', 23)" class="i">seq</span> { <span class="k">for</span> <span onmouseout="hideTip(event, 'fs12', 24)" onmouseover="showTip(event, 'fs12', 24)" class="i">i</span> <span class="k">in</span> <span class="n">1..</span><span class="n">10</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs12', 25)" onmouseover="showTip(event, 'fs12', 25)" class="i">i</span> }
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs14', 26)" onmouseover="showTip(event, 'fs14', 26)" class="i">ys</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs11', 27)" onmouseover="showTip(event, 'fs11', 27)" class="i">seq</span> { <span class="k">for</span> <span onmouseout="hideTip(event, 'fs12', 28)" onmouseover="showTip(event, 'fs12', 28)" class="i">i</span> <span class="k">in</span> <span class="n">11..</span><span class="n">20</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs12', 29)" onmouseover="showTip(event, 'fs12', 29)" class="i">i</span> }
<span onmouseout="hideTip(event, 'fs11', 30)" onmouseover="showTip(event, 'fs11', 30)" class="i">seq</span> {
    <span class="k">yield!</span> <span onmouseout="hideTip(event, 'fs13', 31)" onmouseover="showTip(event, 'fs13', 31)" class="i">xs</span>
    <span class="k">yield!</span> <span onmouseout="hideTip(event, 'fs14', 32)" onmouseover="showTip(event, 'fs14', 32)" class="i">ys</span>
}
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>seq [1; 2; 3; 4; ...]</code></pre></td></tr></table>
<aside class="notes">
In addition to generating a sequence, we can also<br/>
compose multiple sequences into a single sequence<br/>
by concatenating them. This has the same effect as<br/>
calling `Seq.concat` on the two sequences. However,<br/>
the computation expression provides a useful way<br/>
of defining the concatenation according to the rules<br/>
behind each of the bindings. In the former example,<br/>
we used `for` and `yield`. In this example, we used<br/>
two `yield!`. Each binding has a translation rule<br/>
used to compose the program which restrict what can<br/>
be done.<br/>
</aside>
</section>
<section >
<h3>Async<'T></h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
<span class="l">9: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs15', 33)" onmouseover="showTip(event, 'fs15', 33)" class="i">async</span> {
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs16', 34)" onmouseover="showTip(event, 'fs16', 34)" class="i">req</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs17', 35)" onmouseover="showTip(event, 'fs17', 35)" class="t">WebRequest</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs18', 36)" onmouseover="showTip(event, 'fs18', 36)" class="f">Create</span>(<span class="s">&quot;http://openfsharp.org/&quot;</span>)
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs19', 37)" onmouseover="showTip(event, 'fs19', 37)" class="i">resp</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs16', 38)" onmouseover="showTip(event, 'fs16', 38)" class="i">req</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs20', 39)" onmouseover="showTip(event, 'fs20', 39)" class="f">AsyncGetResponse</span>()
    <span class="k">use</span> <span onmouseout="hideTip(event, 'fs21', 40)" onmouseover="showTip(event, 'fs21', 40)" class="i">stream</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 41)" onmouseover="showTip(event, 'fs19', 41)" class="i">resp</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs22', 42)" onmouseover="showTip(event, 'fs22', 42)" class="f">GetResponseStream</span>()
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs23', 43)" onmouseover="showTip(event, 'fs23', 43)" class="i">bytes</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 44)" onmouseover="showTip(event, 'fs21', 44)" class="i">stream</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs24', 45)" onmouseover="showTip(event, 'fs24', 45)" class="f">AsyncRead</span>(<span class="n">91</span>)
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs25', 46)" onmouseover="showTip(event, 'fs25', 46)" class="i">text</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs26', 47)" onmouseover="showTip(event, 'fs26', 47)" class="i">Text</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs27', 48)" onmouseover="showTip(event, 'fs27', 48)" class="t">Encoding</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs28', 49)" onmouseover="showTip(event, 'fs28', 49)" class="i">UTF8</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs29', 50)" onmouseover="showTip(event, 'fs29', 50)" class="f">GetString</span>(<span onmouseout="hideTip(event, 'fs23', 51)" onmouseover="showTip(event, 'fs23', 51)" class="i">bytes</span>)
    <span class="k">return</span> (<span onmouseout="hideTip(event, 'fs19', 52)" onmouseover="showTip(event, 'fs19', 52)" class="i">resp</span> <span class="o">:?&gt;</span> <span onmouseout="hideTip(event, 'fs30', 53)" onmouseover="showTip(event, 'fs30', 53)" class="t">HttpWebResponse</span>)<span class="o">.</span><span class="i">StatusCode</span>, <span onmouseout="hideTip(event, 'fs25', 54)" onmouseover="showTip(event, 'fs25', 54)" class="i">text</span>
}
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs31', 55)" onmouseover="showTip(event, 'fs31', 55)" class="t">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs32', 56)" onmouseover="showTip(event, 'fs32', 56)" class="f">RunSynchronously</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>(OK,
 "&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
	&lt;meta charset="UTF-8"&gt;
	&lt;title&gt;Open F#&lt;/title&gt;")</code></pre></td></tr></table>
<aside class="notes">
Now let's look at an example using Async Workflows.<br/>
It's almost 10 years ago today that [Don Syme](https://twitter.com/dsyme) posted<br/>
[Introducing F# Asynchronous Workflows](https://blogs.msdn.microsoft.com/dsyme/2007/10/10/introducing-f-asynchronous-workflows/).<br/>
When we think of asynchronous and concurrent programming these days, we think of an `async`/`await` pair.<br/>
To the best of my knowledge, this pattern started with F# in 2007.<br/>
Here, we are requesting the Open F# web site, then reading the<br/>
first 91 bytes (through the title) and returning the status code<br/>
and first 91 bytes as text.<br/>
Async computations are delayed and require a call to start them.<br/>
Not all computation expressions have to provide this delay.<br/>
</aside>
</section>
<section >
<h2>Patterns</h2>
<aside class="notes">
Now that we've discussed our motivation and looked<br/>
at some examples, let's move into the patterns for<br/>
building computation expressions.<br/>
I'm sure you already noticed that the previous examples<br/>
use wrapper, or container, types. In other words, these<br/>
are generic types that contain values. Computation expressions<br/>
provide us a mechanism for working with these container types.<br/>
But not all containers are created equal.<br/>
</aside>
</section>
<section >
<blockquote>
<p>Three Rings for the Elven-kings under the sky,<br />
Seven for the Dwarf-lords in their halls of stone,<br />
Nine for Mortal Men doomed to die,<br />
One for the Dark Lord on his dark throne<br />
<br />
In the Land of Mordor where the Shadows lie.<br />
One Ring to rule them all, One Ring to find them,<br />
One Ring to bring them all and in the darkness bind them<br />
In the Land of Mordor where the Shadows lie.<br /></p>
</blockquote>
<p>— J.R.R. Tolkien's epigraph to The Lord of the Rings</p>
<aside class="notes">
I find computation expressions quite poetic, so what better<br/>
way to outline the patterns for building computation expressions<br/>
than with a poem?<br/>
<Read the poem><br/>
I imagine you are wondering why such a dark poem to describe<br/>
this wonderful tool?<br/>
I have found that many of us have followed a similar path in<br/>
understanding computation expressions, and the path starts with<br/>
the bottom of the first stanza then works its way up.<br/>
</aside>
</section>
<section >
<h2>One for the Dark Lord on his dark throne</h2>
<aside class="notes">
We'll come back to this one in just a bit. The motivating<br/>
factor for many when first encroaching into computation<br/>
expressions is to replicate what is found in Haskell or some<br/>
other programming language. For reasons good and bad, the<br/>
topic of monads, which is _not_ the point of this talk, compells<br/>
programmers towards this goal. That leads us to:<br/>
</aside>
</section>
<section >
<h2>Nine for Mortal Men doomed to die</h2>
<aside class="notes">
The Nine became the Nazgul, slaves to the Dark Lord Sauron.<br/>
I found this to be true of me when first trying to understand<br/>
computation expressions, and it blinded me for years to seeing<br/>
and understanding their potential.<br/>
To say that this talk is not about monads isn't entirely true;<br/>
it's just they aren't the main point. We've already looked at two,<br/>
though it's really not important that you fully understand what<br/>
is a monad (or a monoid, applicative, etc.) though it certainly<br/>
won't hurt you to understand why they are valuable and how they<br/>
might help you reason about your code.<br/>
Let's look at another example using `Option<'T>`.<br/>
</aside>
</section>
<section >
<h3>OptionBuilder</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs33', 57)" onmouseover="showTip(event, 'fs33', 57)" class="t">OptionMonad</span>() <span class="o">=</span>
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs34', 58)" onmouseover="showTip(event, 'fs34', 58)" class="f">Bind</span>(<span onmouseout="hideTip(event, 'fs35', 59)" onmouseover="showTip(event, 'fs35', 59)" class="i">m</span>, <span onmouseout="hideTip(event, 'fs36', 60)" onmouseover="showTip(event, 'fs36', 60)" class="f">f</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs37', 61)" onmouseover="showTip(event, 'fs37', 61)" class="t">Option</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs38', 62)" onmouseover="showTip(event, 'fs38', 62)" class="f">bind</span> <span onmouseout="hideTip(event, 'fs36', 63)" onmouseover="showTip(event, 'fs36', 63)" class="f">f</span> <span onmouseout="hideTip(event, 'fs35', 64)" onmouseover="showTip(event, 'fs35', 64)" class="i">m</span>
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs39', 65)" onmouseover="showTip(event, 'fs39', 65)" class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs40', 66)" onmouseover="showTip(event, 'fs40', 66)" class="f">Return</span>(<span onmouseout="hideTip(event, 'fs41', 67)" onmouseover="showTip(event, 'fs41', 67)" class="i">x</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs42', 68)" onmouseover="showTip(event, 'fs42', 68)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs41', 69)" onmouseover="showTip(event, 'fs41', 69)" class="i">x</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs43', 70)" onmouseover="showTip(event, 'fs43', 70)" class="i">opt</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs33', 71)" onmouseover="showTip(event, 'fs33', 71)" class="t">OptionMonad</span>()
</code></pre></td>
</tr>
</table>
<p><a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions">Computation Expressions</a></p>
<aside class="notes">
This is the basic definition of a monad written as a<br/>
computation expression. The computation expression is<br/>
written as a simple .NET class with members having<br/>
certain names and matching a limited range of type signatures.<br/>
We are not going to cover all of the methods and their<br/>
signatures today, but you can find them listed in the Microsoft<br/>
documentation online.<br/>
Unfortunately, this does not quite complete what's possible.<br/>
</aside>
</section>
<section >
<h3>OptionBuilder</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs44', 72)" onmouseover="showTip(event, 'fs44', 72)" class="t">OptionBuilder</span>() <span class="o">=</span>
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs45', 73)" onmouseover="showTip(event, 'fs45', 73)" class="f">Bind</span>(<span onmouseout="hideTip(event, 'fs46', 74)" onmouseover="showTip(event, 'fs46', 74)" class="i">m</span>, <span onmouseout="hideTip(event, 'fs47', 75)" onmouseover="showTip(event, 'fs47', 75)" class="f">f</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs37', 76)" onmouseover="showTip(event, 'fs37', 76)" class="t">Option</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs38', 77)" onmouseover="showTip(event, 'fs38', 77)" class="f">bind</span> <span onmouseout="hideTip(event, 'fs47', 78)" onmouseover="showTip(event, 'fs47', 78)" class="f">f</span> <span onmouseout="hideTip(event, 'fs46', 79)" onmouseover="showTip(event, 'fs46', 79)" class="i">m</span>
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs48', 80)" onmouseover="showTip(event, 'fs48', 80)" class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs49', 81)" onmouseover="showTip(event, 'fs49', 81)" class="f">Return</span>(<span onmouseout="hideTip(event, 'fs50', 82)" onmouseover="showTip(event, 'fs50', 82)" class="i">x</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs42', 83)" onmouseover="showTip(event, 'fs42', 83)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs50', 84)" onmouseover="showTip(event, 'fs50', 84)" class="i">x</span>
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs48', 85)" onmouseover="showTip(event, 'fs48', 85)" class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs51', 86)" onmouseover="showTip(event, 'fs51', 86)" class="f">ReturnFrom</span>(<span onmouseout="hideTip(event, 'fs52', 87)" onmouseover="showTip(event, 'fs52', 87)" class="i">m</span><span class="o">:</span> <span class="o">&#39;</span><span class="i">T</span> <span onmouseout="hideTip(event, 'fs53', 88)" onmouseover="showTip(event, 'fs53', 88)" class="t">option</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 89)" onmouseover="showTip(event, 'fs52', 89)" class="i">m</span>
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs48', 90)" onmouseover="showTip(event, 'fs48', 90)" class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs54', 91)" onmouseover="showTip(event, 'fs54', 91)" class="f">Zero</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fs42', 92)" onmouseover="showTip(event, 'fs42', 92)" class="p">Some</span> ()
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs48', 93)" onmouseover="showTip(event, 'fs48', 93)" class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs55', 94)" onmouseover="showTip(event, 'fs55', 94)" class="f">Combine</span>(<span onmouseout="hideTip(event, 'fs56', 95)" onmouseover="showTip(event, 'fs56', 95)" class="i">m</span>, <span onmouseout="hideTip(event, 'fs57', 96)" onmouseover="showTip(event, 'fs57', 96)" class="f">f</span><span class="o">:</span> <span onmouseout="hideTip(event, 'fs58', 97)" onmouseover="showTip(event, 'fs58', 97)" class="t">unit</span> <span class="k">-&gt;</span> _) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs37', 98)" onmouseover="showTip(event, 'fs37', 98)" class="t">Option</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs38', 99)" onmouseover="showTip(event, 'fs38', 99)" class="f">bind</span> <span onmouseout="hideTip(event, 'fs57', 100)" onmouseover="showTip(event, 'fs57', 100)" class="f">f</span> <span onmouseout="hideTip(event, 'fs56', 101)" onmouseover="showTip(event, 'fs56', 101)" class="i">m</span>
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs48', 102)" onmouseover="showTip(event, 'fs48', 102)" class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs59', 103)" onmouseover="showTip(event, 'fs59', 103)" class="f">Delay</span>(<span onmouseout="hideTip(event, 'fs60', 104)" onmouseover="showTip(event, 'fs60', 104)" class="f">f</span><span class="o">:</span> <span onmouseout="hideTip(event, 'fs58', 105)" onmouseover="showTip(event, 'fs58', 105)" class="t">unit</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">T</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs60', 106)" onmouseover="showTip(event, 'fs60', 106)" class="f">f</span>
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs48', 107)" onmouseover="showTip(event, 'fs48', 107)" class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs61', 108)" onmouseover="showTip(event, 'fs61', 108)" class="f">Run</span>(<span onmouseout="hideTip(event, 'fs62', 109)" onmouseover="showTip(event, 'fs62', 109)" class="f">f</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs62', 110)" onmouseover="showTip(event, 'fs62', 110)" class="f">f</span>()

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs63', 111)" onmouseover="showTip(event, 'fs63', 111)" class="i">maybe</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs44', 112)" onmouseover="showTip(event, 'fs44', 112)" class="t">OptionBuilder</span>()
</code></pre></td>
</tr>
</table>
<aside class="notes">
The previous implementation eagerly evaluates the computation.<br/>
Computation Expressions allow you to insert delays into the<br/>
computation so they don't run eagerly. In addition, we've<br/>
added members to help with combining computations return unit<br/>
with continuing computations.<br/>
</aside>
</section>
<section >
<h3>Delayed Computations</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs64', 113)" onmouseover="showTip(event, 'fs64', 113)" class="i">one</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs63', 114)" onmouseover="showTip(event, 'fs63', 114)" class="i">maybe</span> { <span class="k">return</span> <span class="n">1</span> }
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs65', 115)" onmouseover="showTip(event, 'fs65', 115)" class="f">double</span> <span onmouseout="hideTip(event, 'fs66', 116)" onmouseover="showTip(event, 'fs66', 116)" class="i">x</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs63', 117)" onmouseover="showTip(event, 'fs63', 117)" class="i">maybe</span> { <span class="k">return</span> <span onmouseout="hideTip(event, 'fs66', 118)" onmouseover="showTip(event, 'fs66', 118)" class="i">x</span> <span class="o">*</span> <span class="n">2</span> }
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs67', 119)" onmouseover="showTip(event, 'fs67', 119)" class="i">carryOn</span> <span class="o">=</span> <span class="c">(*true*)</span> <span class="k">false</span>
<span onmouseout="hideTip(event, 'fs63', 120)" onmouseover="showTip(event, 'fs63', 120)" class="i">maybe</span> {
    <span class="k">if</span> <span onmouseout="hideTip(event, 'fs67', 121)" onmouseover="showTip(event, 'fs67', 121)" class="i">carryOn</span> <span class="k">then</span>
        <span onmouseout="hideTip(event, 'fs68', 122)" onmouseover="showTip(event, 'fs68', 122)" class="f">printfn</span> <span class="s">&quot;proceeding&quot;</span>
        <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs66', 123)" onmouseover="showTip(event, 'fs66', 123)" class="i">x</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs64', 124)" onmouseover="showTip(event, 'fs64', 124)" class="i">one</span>
        <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs69', 125)" onmouseover="showTip(event, 'fs69', 125)" class="i">y</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs65', 126)" onmouseover="showTip(event, 'fs65', 126)" class="f">double</span> <span onmouseout="hideTip(event, 'fs66', 127)" onmouseover="showTip(event, 'fs66', 127)" class="i">x</span>
        <span class="k">return</span> <span onmouseout="hideTip(event, 'fs66', 128)" onmouseover="showTip(event, 'fs66', 128)" class="i">x</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs69', 129)" onmouseover="showTip(event, 'fs69', 129)" class="i">y</span>
    <span class="k">else</span> <span class="k">return!</span> <span onmouseout="hideTip(event, 'fs70', 130)" onmouseover="showTip(event, 'fs70', 130)" class="p">None</span>
}
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>No value has been returned</code></pre></td></tr></table>
<aside class="notes">
Here we see that we can retrieve the values of one and two<br/>
and add them together if carryOn is true. Otherwise, we<br/>
can return a None directly using ReturnFrom.<br/>
</aside>
</section>
<section >
<h3>Why should we care?</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
<span class="l">9: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">if</span> <span onmouseout="hideTip(event, 'fs67', 131)" onmouseover="showTip(event, 'fs67', 131)" class="i">carryOn</span> <span class="k">then</span>
    <span onmouseout="hideTip(event, 'fs68', 132)" onmouseover="showTip(event, 'fs68', 132)" class="f">printfn</span> <span class="s">&quot;proceeding&quot;</span>
    <span class="k">match</span> <span onmouseout="hideTip(event, 'fs64', 133)" onmouseover="showTip(event, 'fs64', 133)" class="i">one</span> <span class="k">with</span>
    | <span onmouseout="hideTip(event, 'fs42', 134)" onmouseover="showTip(event, 'fs42', 134)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs66', 135)" onmouseover="showTip(event, 'fs66', 135)" class="i">x</span> <span class="k">-&gt;</span>
        <span class="k">match</span> <span onmouseout="hideTip(event, 'fs65', 136)" onmouseover="showTip(event, 'fs65', 136)" class="f">double</span> <span onmouseout="hideTip(event, 'fs66', 137)" onmouseover="showTip(event, 'fs66', 137)" class="i">x</span> <span class="k">with</span>
        | <span onmouseout="hideTip(event, 'fs42', 138)" onmouseover="showTip(event, 'fs42', 138)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs69', 139)" onmouseover="showTip(event, 'fs69', 139)" class="i">y</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs42', 140)" onmouseover="showTip(event, 'fs42', 140)" class="p">Some</span>(<span onmouseout="hideTip(event, 'fs66', 141)" onmouseover="showTip(event, 'fs66', 141)" class="i">x</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs69', 142)" onmouseover="showTip(event, 'fs69', 142)" class="i">y</span>)
        | <span onmouseout="hideTip(event, 'fs70', 143)" onmouseover="showTip(event, 'fs70', 143)" class="p">None</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs70', 144)" onmouseover="showTip(event, 'fs70', 144)" class="p">None</span>
    | <span onmouseout="hideTip(event, 'fs70', 145)" onmouseover="showTip(event, 'fs70', 145)" class="p">None</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs70', 146)" onmouseover="showTip(event, 'fs70', 146)" class="p">None</span>
<span class="k">else</span> <span onmouseout="hideTip(event, 'fs70', 147)" onmouseover="showTip(event, 'fs70', 147)" class="p">None</span>
</code></pre></td>
</tr>
</table>
<aside class="notes">
The above could be written like this, with nested match expressions.<br/>
The computation expression clearly wins out in terms of succinctness.<br/>
We also don't have to thread all the `None -> None` cases. This may<br/>
not seems like such a big deal until you get into a situation where<br/>
you have to cascade many option values in a long arrowhead pattern,<br/>
e.g. if you are doing some parsing.<br/>
In other words, computation expressions allow us to streamline our<br/>
code such that it looks mostly like normal F# code while making side-<br/>
effects explicit.<br/>
</aside>
</section>
<section >
<h3>Back to the One Ring</h3>
<ul>
<li><a href="https://github.com/gusty/FSharpPlus">FSharpPlus</a></li>
<li><a href="https://github.com/fsprojects/FSharpx.Extras/tree/master/src/FSharpx.Extras/ComputationExpressions">FSharpx.Extras</a></li>
<li><a href="https://github.com/palladin/Higher">Higher</a></li>
</ul>
<aside class="notes">
Much like the Nazgul, seduced by Sauron's power through the One Ring,<br/>
you may get caught in the trap of trying to implement the one, true monad CE.<br/>
Many computations can be written almost exactly alike, assuming they are<br/>
monads. However, F# is not a purely functional, lazy language like Haskell,<br/>
and the implementations cannot be implemented exactly alike.<br/>
The One Ring, in this story, is the Haskell do-notation. FSharpPlus achieved<br/>
do-notation, which is a single computation expression abstraced over any<br/>
monadic type. The implementation is interesting and worth your time to<br/>
investigate, but we won't be diving deeper in this talk.<br/>
Nevertheless, these implementations offer hints to the potential power<br/>
of F# computation expressions we'll see in a bit.<br/>
</aside>
</section>
<section >
<h2>Seven for the Dwarf-lords in their halls of stone</h2>
<aside class="notes">
Okay, let's move towards the light. Or at least a different kind of<br/>
darkness. The rings of the dwarves don't factor into Tolkien's stories<br/>
much, so I can't make a great analogy, but let's assume they were more<br/>
powerful than the rings for men. In that case, I would relate them to<br/>
the query expressions introduced in F# 3.0.<br/>
</aside>
</section>
<section >
<h3>QueryBuilder</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs71', 148)" onmouseover="showTip(event, 'fs71', 148)" class="i">query</span> {
    <span class="k">for</span> <span onmouseout="hideTip(event, 'fs66', 149)" onmouseover="showTip(event, 'fs66', 149)" class="i">x</span> <span class="k">in</span> <span class="n">1..</span><span class="n">10</span> <span class="k">do</span>
    <span class="k">for</span> <span onmouseout="hideTip(event, 'fs69', 150)" onmouseover="showTip(event, 'fs69', 150)" class="i">y</span> <span class="k">in</span> <span class="n">11..</span><span class="n">20</span> <span class="k">do</span>
    <span onmouseout="hideTip(event, 'fs72', 151)" onmouseover="showTip(event, 'fs72', 151)" class="k">where</span> (<span onmouseout="hideTip(event, 'fs66', 152)" onmouseover="showTip(event, 'fs66', 152)" class="i">x</span> <span class="o">%</span> <span class="n">2</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&amp;&amp;</span> <span onmouseout="hideTip(event, 'fs69', 153)" onmouseover="showTip(event, 'fs69', 153)" class="i">y</span> <span class="o">%</span> <span class="n">2</span> <span class="o">=</span> <span class="n">0</span>)
    <span onmouseout="hideTip(event, 'fs73', 154)" onmouseover="showTip(event, 'fs73', 154)" class="k">select</span> (<span onmouseout="hideTip(event, 'fs66', 155)" onmouseover="showTip(event, 'fs66', 155)" class="i">x</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs69', 156)" onmouseover="showTip(event, 'fs69', 156)" class="i">y</span>)
}
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>seq [13; 15; 17; 19; ...]</code></pre></td></tr></table>
<aside class="notes">
F# 3.0, released in 2012, introduced query expressions. In order<br/>
to support query expressions, F# also introduced the `CustomOperationAttribute`.<br/>
Unfortunately, F# 3.0 also introduced type providers, and these drew<br/>
the most excitement in the community. So much so that experimentation with<br/>
computation expressions stagnated. However, some work still continued with<br/>
interesting results.<br/>
</aside>
</section>
<section >
<h3><a href="http://fsprojects.github.io/FSharp.Control.Reactive/">FSharp.Control.Reactive</a></h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs74', 157)" onmouseover="showTip(event, 'fs74', 157)" class="i">rxquery</span> {
    <span class="k">for</span> <span onmouseout="hideTip(event, 'fs66', 158)" onmouseover="showTip(event, 'fs66', 158)" class="i">x</span> <span class="k">in</span> (<span onmouseout="hideTip(event, 'fs75', 159)" onmouseover="showTip(event, 'fs75', 159)" class="t">Observable</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs76', 160)" onmouseover="showTip(event, 'fs76', 160)" class="f">ofSeq</span> [|<span class="n">1..</span><span class="n">10</span>|]) <span class="k">do</span>
    <span onmouseout="hideTip(event, 'fs77', 161)" onmouseover="showTip(event, 'fs77', 161)" class="k">zip</span> <span onmouseout="hideTip(event, 'fs69', 162)" onmouseover="showTip(event, 'fs69', 162)" class="i">y</span> <span class="k">in</span> (<span onmouseout="hideTip(event, 'fs75', 163)" onmouseover="showTip(event, 'fs75', 163)" class="t">Observable</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs76', 164)" onmouseover="showTip(event, 'fs76', 164)" class="f">ofSeq</span> [|<span class="n">11..</span><span class="n">20</span>|])
    <span onmouseout="hideTip(event, 'fs78', 165)" onmouseover="showTip(event, 'fs78', 165)" class="k">select</span> (<span onmouseout="hideTip(event, 'fs66', 166)" onmouseover="showTip(event, 'fs66', 166)" class="i">x</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs69', 167)" onmouseover="showTip(event, 'fs69', 167)" class="i">y</span>)
}
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs75', 168)" onmouseover="showTip(event, 'fs75', 168)" class="t">Observable</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs79', 169)" onmouseover="showTip(event, 'fs79', 169)" class="f">subscribe</span> (<span onmouseout="hideTip(event, 'fs68', 170)" onmouseover="showTip(event, 'fs68', 170)" class="f">printfn</span> <span class="s">&quot;</span><span class="pf">%i</span><span class="s">&quot;</span>)
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>12
14
16
18
20
22
24
26
28
30</code></pre></td></tr></table>
<aside class="notes">
Rx.NET works just fine from F#, but FSharp.Control.Reactive provides extensions<br/>
to the Observable module to fit the F# style. It also provides an `observe`<br/>
computation expression for the monadic operations and `rxquery` for query<br/>
expressions. <br/>
The `for` is one of the standard operators used in computation expressions.<br/>
However, `zip` and `select` are not standard. They are not part of the core<br/>
F# keywords. How do they appear within the language?<br/>
</aside>
</section>
<section >
<h3>RxQueryBuilder Select and Zip</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs80', 171)" onmouseover="showTip(event, 'fs80', 171)" class="t">RxQueryBuilder</span> <span class="k">with</span>

    [&lt;<span onmouseout="hideTip(event, 'fs81', 172)" onmouseover="showTip(event, 'fs81', 172)" class="t">CustomOperation</span>(<span class="s">&quot;select&quot;</span>, <span class="i">AllowIntoPattern</span><span class="o">=</span><span class="k">true</span>)&gt;]
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs82', 173)" onmouseover="showTip(event, 'fs82', 173)" class="f">Select</span> (<span onmouseout="hideTip(event, 'fs83', 174)" onmouseover="showTip(event, 'fs83', 174)" class="i">s</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs84', 175)" onmouseover="showTip(event, 'fs84', 175)" class="t">IObservable</span><span class="o">&lt;</span>_<span class="o">&gt;</span>, 
                      [&lt;<span onmouseout="hideTip(event, 'fs85', 176)" onmouseover="showTip(event, 'fs85', 176)" class="t">ProjectionParameter</span>&gt;] <span onmouseout="hideTip(event, 'fs86', 177)" onmouseover="showTip(event, 'fs86', 177)" class="f">selector</span> <span class="o">:</span> _ <span class="k">-&gt;</span> _) <span class="o">=</span>
        <span onmouseout="hideTip(event, 'fs83', 178)" onmouseover="showTip(event, 'fs83', 178)" class="i">s</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs87', 179)" onmouseover="showTip(event, 'fs87', 179)" class="f">Select</span>(<span onmouseout="hideTip(event, 'fs86', 180)" onmouseover="showTip(event, 'fs86', 180)" class="f">selector</span>)

    [&lt;<span onmouseout="hideTip(event, 'fs81', 181)" onmouseover="showTip(event, 'fs81', 181)" class="t">CustomOperation</span>(<span class="s">&quot;zip&quot;</span>, <span class="i">IsLikeZip</span><span class="o">=</span><span class="k">true</span>)&gt;]
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs88', 182)" onmouseover="showTip(event, 'fs88', 182)" class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs89', 183)" onmouseover="showTip(event, 'fs89', 183)" class="f">Zip</span> (<span onmouseout="hideTip(event, 'fs90', 184)" onmouseover="showTip(event, 'fs90', 184)" class="i">s1</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs84', 185)" onmouseover="showTip(event, 'fs84', 185)" class="t">IObservable</span><span class="o">&lt;</span>_<span class="o">&gt;</span>,
                   <span onmouseout="hideTip(event, 'fs91', 186)" onmouseover="showTip(event, 'fs91', 186)" class="i">s2</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs84', 187)" onmouseover="showTip(event, 'fs84', 187)" class="t">IObservable</span><span class="o">&lt;</span>_<span class="o">&gt;</span>,
                   [&lt;<span onmouseout="hideTip(event, 'fs85', 188)" onmouseover="showTip(event, 'fs85', 188)" class="t">ProjectionParameter</span>&gt;] <span onmouseout="hideTip(event, 'fs92', 189)" onmouseover="showTip(event, 'fs92', 189)" class="f">resultSelector</span> <span class="o">:</span> _ <span class="k">-&gt;</span> _) <span class="o">=</span>
        <span onmouseout="hideTip(event, 'fs90', 190)" onmouseover="showTip(event, 'fs90', 190)" class="i">s1</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs93', 191)" onmouseover="showTip(event, 'fs93', 191)" class="f">Zip</span>(<span onmouseout="hideTip(event, 'fs91', 192)" onmouseover="showTip(event, 'fs91', 192)" class="i">s2</span>, <span class="k">new</span> <span onmouseout="hideTip(event, 'fs94', 193)" onmouseover="showTip(event, 'fs94', 193)" class="t">Func</span><span class="o">&lt;</span>_,_,_<span class="o">&gt;</span>(<span onmouseout="hideTip(event, 'fs92', 194)" onmouseover="showTip(event, 'fs92', 194)" class="f">resultSelector</span>))
</code></pre></td>
</tr>
</table>
<aside class="notes">
These are two custom operations introduced in F# 3.0 with the<br/>
query expressions. Note that we give the name in the `CustomOperationAttribute`.<br/>
The attribute accepts additional parameters, such as `AllowIntoPattern`,<br/>
`IsLikeZip`, etc. The full set of options is outside the scope of this talk,<br/>
but you can find them listed in the Microsoft docs online and in the full<br/>
implementation of the `RxQueryBuilder`.<br/>
The FSharp.Control.Reactive library made an interesting choice in providing<br/>
both the `observe` CE and the `rxquery` QE. There's no reason you cannot mix<br/>
the two in one builder. It turns out, you can also extend an existing builder<br/>
with new custom operations.<br/>
</aside>
</section>
<section >
<h3>Extending Existing Builders</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs7', 195)" onmouseover="showTip(event, 'fs7', 195)" class="i">FSharp</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs8', 196)" onmouseover="showTip(event, 'fs8', 196)" class="i">Control</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs95', 197)" onmouseover="showTip(event, 'fs95', 197)" class="t">AsyncBuilder</span> <span class="k">with</span>

    [&lt;<span onmouseout="hideTip(event, 'fs81', 198)" onmouseover="showTip(event, 'fs81', 198)" class="t">CustomOperation</span>(<span class="s">&quot;and!&quot;</span>, <span class="i">IsLikeZip</span><span class="o">=</span><span class="k">true</span>)&gt;]
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs96', 199)" onmouseover="showTip(event, 'fs96', 199)" class="f">Merge</span>(<span onmouseout="hideTip(event, 'fs97', 200)" onmouseover="showTip(event, 'fs97', 200)" class="i">x</span>, <span onmouseout="hideTip(event, 'fs98', 201)" onmouseover="showTip(event, 'fs98', 201)" class="i">y</span>, <span onmouseout="hideTip(event, 'fs99', 202)" onmouseover="showTip(event, 'fs99', 202)" class="f">f</span>) <span class="o">=</span>
        <span onmouseout="hideTip(event, 'fs15', 203)" onmouseover="showTip(event, 'fs15', 203)" class="i">async</span> {
            <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs100', 204)" onmouseover="showTip(event, 'fs100', 204)" class="i">token</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 205)" onmouseover="showTip(event, 'fs31', 205)" class="t">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs101', 206)" onmouseover="showTip(event, 'fs101', 206)" class="i">CancellationToken</span>
            <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs102', 207)" onmouseover="showTip(event, 'fs102', 207)" class="i">x&#39;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 208)" onmouseover="showTip(event, 'fs31', 208)" class="t">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs103', 209)" onmouseover="showTip(event, 'fs103', 209)" class="f">StartChildAsTask</span> <span onmouseout="hideTip(event, 'fs97', 210)" onmouseover="showTip(event, 'fs97', 210)" class="i">x</span>
            <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs104', 211)" onmouseover="showTip(event, 'fs104', 211)" class="i">y&#39;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 212)" onmouseover="showTip(event, 'fs31', 212)" class="t">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs103', 213)" onmouseover="showTip(event, 'fs103', 213)" class="f">StartChildAsTask</span> <span onmouseout="hideTip(event, 'fs98', 214)" onmouseover="showTip(event, 'fs98', 214)" class="i">y</span>
            <span class="k">do</span> <span onmouseout="hideTip(event, 'fs1', 215)" onmouseover="showTip(event, 'fs1', 215)" class="i">System</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs105', 216)" onmouseover="showTip(event, 'fs105', 216)" class="i">Threading</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs106', 217)" onmouseover="showTip(event, 'fs106', 217)" class="i">Tasks</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs107', 218)" onmouseover="showTip(event, 'fs107', 218)" class="t">Task</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs108', 219)" onmouseover="showTip(event, 'fs108', 219)" class="f">WaitAll</span>([|<span onmouseout="hideTip(event, 'fs102', 220)" onmouseover="showTip(event, 'fs102', 220)" class="i">x&#39;</span>;<span onmouseout="hideTip(event, 'fs104', 221)" onmouseover="showTip(event, 'fs104', 221)" class="i">y&#39;</span>|], <span class="i">cancellationToken</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs100', 222)" onmouseover="showTip(event, 'fs100', 222)" class="i">token</span>)
            <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs109', 223)" onmouseover="showTip(event, 'fs109', 223)" class="i">x&#39;&#39;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 224)" onmouseover="showTip(event, 'fs31', 224)" class="t">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs110', 225)" onmouseover="showTip(event, 'fs110', 225)" class="f">AwaitTask</span> <span onmouseout="hideTip(event, 'fs102', 226)" onmouseover="showTip(event, 'fs102', 226)" class="i">x&#39;</span>
            <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs111', 227)" onmouseover="showTip(event, 'fs111', 227)" class="i">y&#39;&#39;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 228)" onmouseover="showTip(event, 'fs31', 228)" class="t">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs110', 229)" onmouseover="showTip(event, 'fs110', 229)" class="f">AwaitTask</span> <span onmouseout="hideTip(event, 'fs104', 230)" onmouseover="showTip(event, 'fs104', 230)" class="i">y&#39;</span>
            <span class="k">return</span> <span onmouseout="hideTip(event, 'fs99', 231)" onmouseover="showTip(event, 'fs99', 231)" class="f">f</span> <span onmouseout="hideTip(event, 'fs109', 232)" onmouseover="showTip(event, 'fs109', 232)" class="i">x&#39;&#39;</span> <span onmouseout="hideTip(event, 'fs111', 233)" onmouseover="showTip(event, 'fs111', 233)" class="i">y&#39;&#39;</span>
        }

    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs112', 234)" onmouseover="showTip(event, 'fs112', 234)" class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs113', 235)" onmouseover="showTip(event, 'fs113', 235)" class="f">For</span>(<span onmouseout="hideTip(event, 'fs114', 236)" onmouseover="showTip(event, 'fs114', 236)" class="i">m</span>, <span onmouseout="hideTip(event, 'fs115', 237)" onmouseover="showTip(event, 'fs115', 237)" class="f">f</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs112', 238)" onmouseover="showTip(event, 'fs112', 238)" class="i">__</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs116', 239)" onmouseover="showTip(event, 'fs116', 239)" class="f">Bind</span>(<span onmouseout="hideTip(event, 'fs114', 240)" onmouseover="showTip(event, 'fs114', 240)" class="i">m</span>, <span onmouseout="hideTip(event, 'fs115', 241)" onmouseover="showTip(event, 'fs115', 241)" class="f">f</span>)
</code></pre></td>
</tr>
</table>
<aside class="notes">
If you ever wished you could run two or more async computations in parallel<br/>
within an async computation expression, now you know you can by extending the<br/>
AsyncBuilder provided with FSharp.Core.<br/>
</aside>
</section>
<section >
<h3>Async Applicative Example</h3>
<aside class="notes">
Jump to VSCode to run this in FSI, as the code snippet is too long.<br/>
The code compares awaiting two sleeps and shows that the applicative,<br/>
which does not require awaiting the first value, can freely run in<br/>
parallel, whereas the monad version using `let!` must wait for each<br/>
in turn.<br/>
We could argue about the best syntax, but this version uses that proposed<br/>
in the VisualFSharp issues: https://github.com/fsharp/fslang-suggestions/issues/579<br/>
</aside>
</section>
<section >
<h2>Three Rings for the Elven-kings under the sky</h2>
</section>
<section >
<h2><a href="https://freya.io/">Freya</a></h2>
</section>
<section >
<h2><a href="https://github.com/kbattocchi/ILBuilder">ILBuilder</a></h2>
<h2><a href="https://github.com/rspeele/LicenseToCIL">LicenseToCIL</a></h2>
</section>
<section >
<h2>Questions?</h2>
</section>
<section >
<h2>Why Not Macros?</h2>
<aside class="notes">
Since we are talking about language extensions, we must first<br/>
talk about macros. After all, languages in the Lisp family<br/>
support macros, to the extent that much of the language is built<br/>
in macros. What could be more powerful? In short, nothing.<br/>
However, F# does not provide a mechanism for writing macros,<br/>
and it's a fair question to ask, "Why not?"<br/>
Macros require a pre-compiler or a compiler plugin mechanism.<br/>
When you introduce something like this, you are either on<br/>
some other tool to handle some of the work of compiling a program.<br/>
This can drastically increase and complicate compile times or even<br/>
create very difficult-to-debug compiler crashes.<br/>
In addition, macros don't play very well with typed languages<br/>
as you are essentially relying on something typed to rely on<br/>
something untyped-until-generated.<br/>
Type Providers are the closest thing F# has to macros, but these<br/>
only provide types and don't extend the language.<br/>
Computation expressions don't carry the full power of macros,<br/>
but they cover the most important use cases to the point you won't<br/>
likely miss macros.<br/>
</aside>
</section>
<section >
<h2>Will F# ever get Type Classes?</h2>
<h3><a href="https://github.com/MattoWindsor91/visualfsharp/blob/hackathon-vs/examples/fsconcepts.md">Classes for the Masses</a></h3>
<aside class="notes">
Incidentally, type classes, which Haskell uses to encode monads and other<br/>
container types, have a proven encoding in F# and may be coming in a future<br/>
release. Hopefully this will alleviate some of the pit of computation-<br/>
expressions-as-monad-encodings that many fall into.<br/>
</aside>
</section>
<section >
<h2>References</h2>
<ol>
<li><a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions">Computation Expressions</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/query-expressions">Query Expressions</a></li>
<li><a href="https://vimeo.com/47218436">Computation Expresssions in F# 3.0</a></li>
<li><a href="https://blogs.msdn.microsoft.com/dsyme/2007/10/10/introducing-f-asynchronous-workflows/">Introducing F# Asynchronous Workflows</a></li>
<li><a href="http://tomasp.net/academic/papers/computation-zoo/computation-zoo.pdf">The F# Computation Expression Zoo</a></li>
<li><a href="https://fsharpforfunandprofit.com/series/computation-expressions.html">F# for fun and profit</a></li>
<li><a href="https://github.com/fsharp/fslang-suggestions/issues/579">Support let! .. and... for applicative functors</a></li>
</ol>
</section>


        </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script>
        // Add the nohighlight class and data-noescape attribute to code elements that have already been formatted by FSharp.Formatting
        $('pre.highlighted code').addClass('nohighlight').attr('data-noescape', '');

        // Full list of configuration options available here:
        // https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            controls: true,
            progress: true,
            history: true,
            center: true,

            transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

            // Parallax scrolling
            // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
            // parallaxBackgroundSize: '2100px 900px',

            // Optional libraries used to extend on reveal.js
            dependencies: [
                { src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
                { src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
                { src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
                { src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
                { src: 'plugin/zoom-js/zoom.js', async: true, condition: function () { return !!document.body.classList; } },
                { src: 'plugin/notes/notes.js', async: true, condition: function () { return !!document.body.classList; } }
            ]
        });

    </script>
</body>
</html>

