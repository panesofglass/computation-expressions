<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Extending F# through Computation Expressions</title>
    <meta name="description" content="Explore patterns for extending the F# language using the computation expressions feature">
    <meta name="author" content="Ryan Riley">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="//code.jquery.com/jquery-1.8.0.js"></script>
    <script src="//code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">
    <link type="text/css" rel="stylesheet" href="fsharp.formatting/styles/style.css" />
    <link type="text/css" rel="stylesheet" href="fsharp.formatting/styles/deedle.css" />
    <link type="text/css" rel="stylesheet" href="css/custom.css" />
    <script src="fsharp.formatting/styles/tips.js" type="text/javascript"></script>
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link rel="stylesheet" href="css/fsreveal.css">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
    <script language="javascript" type="text/javascript">
        function init()
        {
            websocket = new WebSocket("ws://"+window.location.host+"/websocket");
            websocket.onmessage = function(evt) { location.reload(); };
        }
        window.addEventListener("load", init, false);
    </script>
</head>
<body>
    <div class="reveal">
        
        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section >
<h2>Extending F# through Computation Expressions</h2>
<h3>Ryan Riley</h3>
</section>
<section >
<h2>Prerequisites</h2>
<aside class="notes">
This is a somewhat advanced level talk in that I assume<br/>
you know or are familiar with a few of the more advanced<br/>
aspects of F# or similar languages, including:<br/>
- how to write a computation expression<br/>
- monoids, monads, applicatives, etc.<br/>
- statically resolved type parameters<br/>
- .NET method overloading<br/>
</aside>
</section>
<section >
<h2>Motivation</h2>
<aside class="notes">
One of the goals of this conference was to not dive into<br/>
language features for their own sake. I don't intend to<br/>
just tell you about computation expressions, nor do I intend<br/>
to cover the academic aspects, which you can find in other<br/>
talks and papers.<br/>
I want to convey the power of computation expressions as they<br/>
relate to solving problems. What sorts of problems? I hope<br/>
to show computation expressions are useful for solving many<br/>
different types of problems, as many as may be solved by<br/>
writing computer programs.<br/>
That seems quite broad, and I agree. It's quite possible that<br/>
computation expressions are really just a fancy way to do<br/>
what we already do in F# or any other language, but I'll leave<br/>
you to decide that at the end. I hope to show you that, at the<br/>
very least, computation expressions can offer a useful model<br/>
for writing correct programs for a given domain.<br/>
</aside>
</section>
<section >
<section >
<h2>Examples</h2>
<aside class="notes">
Let's begin with a few examples built into the language.<br/>
</aside>
</section>
<section >
<h3>Seq<'T></h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">seq</span> {
    <span class="k">for</span> <span class="i">i</span> <span class="k">in</span> <span class="n">1..</span><span class="n">10</span> <span class="k">do</span>
    <span class="k">yield</span> <span class="i">i</span>
}
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>seq [1; 2; 3; 4; ...]</code></pre></td></tr></table>
<aside class="notes">
F# has several list-like comprehensions, including list,<br/>
array, and seq. Here I've chosen to show seq since it looks<br/>
the most like the standard computation expression syntax.<br/>
It's worth noting that there are several seq-related<br/>
optimizations built into the compiler (according to Dave Thomas)<br/>
that are not available to normal computation expressions,<br/>
but this serves as a useful example for the list-like<br/>
syntax.<br/>
</aside>
</section>
<section >
<h3>Concatenating Seq<'T></h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">xs</span> <span class="o">=</span> <span class="i">seq</span> { <span class="k">for</span> <span class="i">i</span> <span class="k">in</span> <span class="n">1..</span><span class="n">10</span> <span class="k">-&gt;</span> <span class="i">i</span> }
<span class="k">let</span> <span class="i">ys</span> <span class="o">=</span> <span class="i">seq</span> { <span class="k">for</span> <span class="i">i</span> <span class="k">in</span> <span class="n">11..</span><span class="n">20</span> <span class="k">-&gt;</span> <span class="i">i</span> }
<span class="i">seq</span> {
    <span class="k">yield!</span> <span class="i">xs</span>
    <span class="k">yield!</span> <span class="i">ys</span>
}
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>seq [1; 2; 3; 4; ...]</code></pre></td></tr></table>
<aside class="notes">
In addition to generating a sequence, we can also<br/>
compose multiple sequences into a single sequence<br/>
by concatenating them. This has the same effect as<br/>
calling `Seq.concat` on the two sequences. However,<br/>
the computation expression provides a useful way<br/>
of defining the concatenation according to the rules<br/>
behind each of the bindings. In the former example,<br/>
we used `for` and `yield`. In this example, we used<br/>
two `yield!`. Each binding has a translation rule<br/>
used to compose the program which restrict what can<br/>
be done.<br/>
</aside>
</section>
<section >
<h3>Async<'T></h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
<span class="l">9: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">async</span> {
    <span class="k">let</span> <span class="i">req</span> <span class="o">=</span> <span class="i">WebRequest</span><span class="o">.</span><span class="i">Create</span>(<span class="s">&quot;http://openfsharp.org/&quot;</span>)
    <span class="k">let!</span> <span class="i">resp</span> <span class="o">=</span> <span class="i">req</span><span class="o">.</span><span class="i">AsyncGetResponse</span>()
    <span class="k">use</span> <span class="i">stream</span> <span class="o">=</span> <span class="i">resp</span><span class="o">.</span><span class="i">GetResponseStream</span>()
    <span class="k">let!</span> <span class="i">bytes</span> <span class="o">=</span> <span class="i">stream</span><span class="o">.</span><span class="i">AsyncRead</span>(<span class="n">91</span>)
    <span class="k">let</span> <span class="i">text</span> <span class="o">=</span> <span class="i">Text</span><span class="o">.</span><span class="i">Encoding</span><span class="o">.</span><span class="i">UTF8</span><span class="o">.</span><span class="i">GetString</span>(<span class="i">bytes</span>)
    <span class="k">return</span> (<span class="i">resp</span> <span class="o">:?&gt;</span> <span class="i">HttpWebResponse</span>)<span class="o">.</span><span class="i">StatusCode</span>, <span class="i">text</span>
}
<span class="o">|&gt;</span> <span class="i">Async</span><span class="o">.</span><span class="i">RunSynchronously</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>(OK,
 "&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
	&lt;meta charset="UTF-8"&gt;
	&lt;title&gt;Open F#&lt;/title&gt;")</code></pre></td></tr></table>
<aside class="notes">
Now let's look at an example using Async Workflows.<br/>
It's almost 10 years ago today that [Don Syme](https://twitter.com/dsyme) posted<br/>
[Introducing F# Asynchronous Workflows](https://blogs.msdn.microsoft.com/dsyme/2007/10/10/introducing-f-asynchronous-workflows/).<br/>
When we think of asynchronous and concurrent programming these days, we think of an `async`/`await` pair.<br/>
To the best of my knowledge, this pattern started with F# in 2007.<br/>
Here, we are requesting the Open F# web site, then reading the<br/>
first 91 bytes (through the title) and returning the status code<br/>
and first 91 bytes as text.<br/>
Async computations are delayed and require a call to start them.<br/>
Not all computation expressions have to provide this delay.<br/>
</aside>
</section>
</section>
<section >
<h2>Patterns</h2>
<aside class="notes">
Now that we've discussed our motivation and looked<br/>
at some examples, let's move into the patterns for<br/>
building computation expressions.<br/>
I'm sure you already noticed that the previous examples<br/>
use wrapper, or container, types. In other words, these<br/>
are generic types that contain values. Computation expressions<br/>
provide us a mechanism for working with these container types.<br/>
But not all containers are created equal.<br/>
</aside>
</section>
<section >
<blockquote>
<p>Three Rings for the Elven-kings under the sky,<br />
Seven for the Dwarf-lords in their halls of stone,<br />
Nine for Mortal Men doomed to die,<br />
One for the Dark Lord on his dark throne<br />
<br />
In the Land of Mordor where the Shadows lie.<br />
One Ring to rule them all, One Ring to find them,<br />
One Ring to bring them all and in the darkness bind them<br />
In the Land of Mordor where the Shadows lie.<br /></p>
</blockquote>
<p>— J.R.R. Tolkien's epigraph to The Lord of the Rings</p>
<aside class="notes">
I find computation expressions quite poetic, so what better<br/>
way to outline the patterns for building computation expressions<br/>
than with a poem?<br/>
<Read the poem><br/>
I imagine you are wondering why such a dark poem to describe<br/>
this wonderful tool?<br/>
I have found that many of us have followed a similar path in<br/>
understanding computation expressions, and the path starts with<br/>
the bottom of the first stanza then works its way up.<br/>
</aside>
</section>
<section >
<h2>One for the Dark Lord on his dark throne</h2>
<p><a href="http://stock-wallpapers.com/wp-content/uploads/2015/01/Lord-of-the-Rings-Wallpapers-Free-Download-9.jpg"><img src="images/one-ring.jpg" alt="The One Ring" /></a></p>
<aside class="notes">
We'll come back to this one in just a bit. The motivating<br/>
factor for many when first encroaching into computation<br/>
expressions is to replicate what is found in Haskell or some<br/>
other programming language. For reasons good and bad, the<br/>
topic of monads, which is _not_ the point of this talk, compells<br/>
programmers towards this goal. That leads us to:<br/>
</aside>
</section>
<section >
<section >
<h2>Nine for Mortal Men doomed to die</h2>
<p><a href="http://www.itsvery.net/lord-of-the-rings.html"><img src="images/9rings.jpg" alt="Nine rings for mortal men" /></a></p>
<aside class="notes">
The Nine became the Nazgul, slaves to the Dark Lord Sauron.<br/>
I found this to be true of me when first trying to understand<br/>
computation expressions, and it blinded me for years to seeing<br/>
and understanding their potential.<br/>
To say that this talk is not about monads isn't entirely true;<br/>
it's just they aren't the main point. We've already looked at two,<br/>
though it's really not important that you fully understand what<br/>
is a monad (or a monoid, applicative, etc.) though it certainly<br/>
won't hurt you to understand why they are valuable and how they<br/>
might help you reason about your code.<br/>
Let's look at another example using `Option<'T>`.<br/>
</aside>
</section>
<section >
<h3>OptionBuilder</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">OptionMonad</span>() <span class="o">=</span>
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Bind</span>(<span class="i">m</span>, <span class="i">f</span>) <span class="o">=</span> <span class="i">Option</span><span class="o">.</span><span class="i">bind</span> <span class="i">f</span> <span class="i">m</span>
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Return</span>(<span class="i">x</span>) <span class="o">=</span> <span class="i">Some</span> <span class="i">x</span>

<span class="k">let</span> <span class="i">opt</span> <span class="o">=</span> <span class="i">OptionMonad</span>()
</code></pre></td>
</tr>
</table>
<p><a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions">Computation Expressions</a></p>
<aside class="notes">
This is the basic definition of a monad written as a<br/>
computation expression. The computation expression is<br/>
written as a simple .NET class with members having<br/>
certain names and matching a limited range of type signatures.<br/>
We are not going to cover all of the methods and their<br/>
signatures today, but you can find them listed in the Microsoft<br/>
documentation online.<br/>
Unfortunately, this does not quite complete what's possible.<br/>
</aside>
</section>
<section >
<h3>OptionBuilder</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">OptionBuilder</span>() <span class="o">=</span>
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Bind</span>(<span class="i">m</span>, <span class="i">f</span>) <span class="o">=</span> <span class="i">Option</span><span class="o">.</span><span class="i">bind</span> <span class="i">f</span> <span class="i">m</span>
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Return</span>(<span class="i">x</span>) <span class="o">=</span> <span class="i">Some</span> <span class="i">x</span>
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">ReturnFrom</span>(<span class="i">m</span><span class="o">:</span> <span class="o">&#39;</span><span class="i">T</span> <span class="i">option</span>) <span class="o">=</span> <span class="i">m</span>
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Zero</span>() <span class="o">=</span> <span class="i">Some</span> ()
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Combine</span>(<span class="i">m</span>, <span class="i">f</span><span class="o">:</span> <span class="i">unit</span> <span class="k">-&gt;</span> _) <span class="o">=</span> <span class="i">Option</span><span class="o">.</span><span class="i">bind</span> <span class="i">f</span> <span class="i">m</span>
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Delay</span>(<span class="i">f</span><span class="o">:</span> <span class="i">unit</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">T</span>) <span class="o">=</span> <span class="i">f</span>
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Run</span>(<span class="i">f</span>) <span class="o">=</span> <span class="i">f</span>()

<span class="k">let</span> <span class="i">maybe</span> <span class="o">=</span> <span class="i">OptionBuilder</span>()
</code></pre></td>
</tr>
</table>
<aside class="notes">
The previous implementation eagerly evaluates the computation.<br/>
Computation Expressions allow you to insert delays into the<br/>
computation so they don't run eagerly. In addition, we've<br/>
added members to help with combining computations return unit<br/>
with continuing computations.<br/>
</aside>
</section>
<section >
<h3>Delayed Computations</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">one</span> <span class="o">=</span> <span class="i">maybe</span> { <span class="k">return</span> <span class="n">1</span> }
<span class="k">let</span> <span class="i">double</span> <span class="i">x</span> <span class="o">=</span> <span class="i">maybe</span> { <span class="k">return</span> <span class="i">x</span> <span class="o">*</span> <span class="n">2</span> }
<span class="k">let</span> <span class="i">carryOn</span> <span class="o">=</span> <span class="c">(*true*)</span> <span class="k">false</span>
<span class="i">maybe</span> {
    <span class="k">if</span> <span class="i">carryOn</span> <span class="k">then</span>
        <span class="i">printfn</span> <span class="s">&quot;proceeding&quot;</span>
        <span class="k">let!</span> <span class="i">x</span> <span class="o">=</span> <span class="i">one</span>
        <span class="k">let!</span> <span class="i">y</span> <span class="o">=</span> <span class="i">double</span> <span class="i">x</span>
        <span class="k">return</span> <span class="i">x</span> <span class="o">+</span> <span class="i">y</span>
    <span class="k">else</span> <span class="k">return!</span> <span class="i">None</span>
}
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>&lt;null&gt;</code></pre></td></tr></table>
<aside class="notes">
Here we see that we can retrieve the values of one and two<br/>
and add them together if carryOn is true. Otherwise, we<br/>
can return a None directly using ReturnFrom.<br/>
</aside>
</section>
<section >
<h3>Why should we care?</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
<span class="l">9: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">if</span> <span class="i">carryOn</span> <span class="k">then</span>
    <span class="i">printfn</span> <span class="s">&quot;proceeding&quot;</span>
    <span class="k">match</span> <span class="i">one</span> <span class="k">with</span>
    | <span class="i">Some</span> <span class="i">x</span> <span class="k">-&gt;</span>
        <span class="k">match</span> <span class="i">double</span> <span class="i">x</span> <span class="k">with</span>
        | <span class="i">Some</span> <span class="i">y</span> <span class="k">-&gt;</span> <span class="i">Some</span>(<span class="i">x</span> <span class="o">+</span> <span class="i">y</span>)
        | <span class="i">None</span> <span class="k">-&gt;</span> <span class="i">None</span>
    | <span class="i">None</span> <span class="k">-&gt;</span> <span class="i">None</span>
<span class="k">else</span> <span class="i">None</span>
</code></pre></td>
</tr>
</table>
<aside class="notes">
The above could be written like this, with nested match expressions.<br/>
The computation expression clearly wins out in terms of succinctness.<br/>
We also don't have to thread all the `None -> None` cases. This may<br/>
not seems like such a big deal until you get into a situation where<br/>
you have to cascade many option values in a long arrowhead pattern,<br/>
e.g. if you are doing some parsing.<br/>
In other words, computation expressions allow us to streamline our<br/>
code such that it looks mostly like normal F# code while making side-<br/>
effects explicit.<br/>
</aside>
</section>
<section >
<h3>Back to the One Ring ...</h3>
<p><a href="http://lotr.wikia.com/wiki/File:Worst-Does-all-of-this-prequel-Sauron-stuff-line-up-with-LOTR.jpg?file=Worst-Does-all-of-this-prequel-Sauron-stuff-line-up-with-LOTR.jpg"><img src="images/eye-of-sauron.jpg" alt="Eye of Sauron" /></a></p>
</section>
<section >
<p><a href="http://pin.it/gwNsF5C"><img src="images/nazgul.jpg" alt="Nazgul" /></a></p>
<aside class="notes">
Much like the Nazgul, seduced by Sauron's power through the One Ring,<br/>
you may get caught in the trap of trying to implement the one, true monad CE.<br/>
Many computations can be written almost exactly alike, assuming they are<br/>
monads. However, F# is not a purely functional, lazy language like Haskell,<br/>
and the implementations cannot be implemented exactly alike.<br/>
</aside>
</section>
<section >
<h3>Monad (+more) libraries</h3>
<ul>
<li><a href="https://github.com/gusty/FSharpPlus">FSharpPlus</a></li>
<li><a href="https://github.com/fsprojects/FSharpx.Extras/tree/master/src/FSharpx.Extras/ComputationExpressions">FSharpx.Extras</a></li>
<li><a href="https://github.com/palladin/Higher">Higher</a></li>
</ul>
<aside class="notes">
The One Ring, in this story, is the Haskell do-notation. FSharpPlus achieved<br/>
do-notation, which is a single computation expression abstraced over any<br/>
monadic type. The implementation is interesting and worth your time to<br/>
investigate, but we won't be diving deeper in this talk.<br/>
Nevertheless, these implementations offer hints to the potential power<br/>
of F# computation expressions we'll see in a bit.<br/>
</aside>
</section>
</section>
<section >
<section >
<h2>Seven for the Dwarf-lords in their halls of stone</h2>
<p><a href="https://heirsofdurin.files.wordpress.com/2013/10/dwarf-lords.jpg"><img src="images/dwarf-lords.jpg" alt="Dwarf lords" /></a></p>
<aside class="notes">
Okay, let's move towards the light. Or at least a different kind of<br/>
darkness. The rings of the dwarves don't factor into Tolkien's stories<br/>
much, so I can't make a great analogy, but let's assume they were more<br/>
powerful than the rings for men. In that case, I would relate them to<br/>
the query expressions introduced in F# 3.0.<br/>
</aside>
</section>
<section >
<h3>QueryBuilder</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">query</span> {
    <span class="k">for</span> <span class="i">x</span> <span class="k">in</span> <span class="n">1..</span><span class="n">10</span> <span class="k">do</span>
    <span class="k">for</span> <span class="i">y</span> <span class="k">in</span> <span class="n">11..</span><span class="n">20</span> <span class="k">do</span>
    <span class="i">where</span> (<span class="i">x</span> <span class="o">%</span> <span class="n">2</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&amp;&amp;</span> <span class="i">y</span> <span class="o">%</span> <span class="n">2</span> <span class="o">=</span> <span class="n">0</span>)
    <span class="i">select</span> (<span class="i">x</span> <span class="o">+</span> <span class="i">y</span>)
}
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>seq [13; 15; 17; 19; ...]</code></pre></td></tr></table>
<aside class="notes">
F# 3.0, released in 2012, introduced query expressions. In order<br/>
to support query expressions, F# also introduced the `CustomOperationAttribute`.<br/>
Unfortunately, F# 3.0 also introduced type providers, and these drew<br/>
the most excitement in the community. So much so that experimentation with<br/>
computation expressions stagnated. However, some work still continued with<br/>
interesting results.<br/>
</aside>
</section>
<section >
<h3><a href="http://fsprojects.github.io/FSharp.Control.Reactive/">FSharp.Control.Reactive</a></h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">rxquery</span> {
    <span class="k">for</span> <span class="i">x</span> <span class="k">in</span> (<span class="i">Observable</span><span class="o">.</span><span class="i">ofSeq</span> [|<span class="n">1..</span><span class="n">10</span>|]) <span class="k">do</span>
    <span class="i">zip</span> <span class="i">y</span> <span class="k">in</span> (<span class="i">Observable</span><span class="o">.</span><span class="i">ofSeq</span> [|<span class="n">11..</span><span class="n">20</span>|])
    <span class="i">select</span> (<span class="i">x</span> <span class="o">+</span> <span class="i">y</span>)
}
<span class="o">|&gt;</span> <span class="i">Observable</span><span class="o">.</span><span class="i">subscribe</span> (<span class="i">printfn</span> <span class="s">&quot;%i&quot;</span>)
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>No output has been produced.</code></pre></td></tr></table>
<aside class="notes">
Rx.NET works just fine from F#, but FSharp.Control.Reactive provides extensions<br/>
to the Observable module to fit the F# style. It also provides an `observe`<br/>
computation expression for the monadic operations and `rxquery` for query<br/>
expressions. <br/>
The `for` is one of the standard operators used in computation expressions.<br/>
However, `zip` and `select` are not standard. They are not part of the core<br/>
F# keywords. How do they appear within the language?<br/>
</aside>
</section>
<section >
<h3>RxQueryBuilder Select and Zip</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">RxQueryBuilder</span> <span class="k">with</span>

    [&lt;<span class="i">CustomOperation</span>(<span class="s">&quot;select&quot;</span>, <span class="i">AllowIntoPattern</span><span class="o">=</span><span class="k">true</span>)&gt;]
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Select</span> (<span class="i">s</span><span class="o">:</span><span class="i">IObservable</span><span class="o">&lt;</span>_<span class="o">&gt;</span>, 
                      [&lt;<span class="i">ProjectionParameter</span>&gt;] <span class="i">selector</span> <span class="o">:</span> _ <span class="k">-&gt;</span> _) <span class="o">=</span>
        <span class="i">s</span><span class="o">.</span><span class="i">Select</span>(<span class="i">selector</span>)

    [&lt;<span class="i">CustomOperation</span>(<span class="s">&quot;zip&quot;</span>, <span class="i">IsLikeZip</span><span class="o">=</span><span class="k">true</span>)&gt;]
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Zip</span> (<span class="i">s1</span><span class="o">:</span><span class="i">IObservable</span><span class="o">&lt;</span>_<span class="o">&gt;</span>,
                   <span class="i">s2</span><span class="o">:</span><span class="i">IObservable</span><span class="o">&lt;</span>_<span class="o">&gt;</span>,
                   [&lt;<span class="i">ProjectionParameter</span>&gt;] <span class="i">resultSelector</span> <span class="o">:</span> _ <span class="k">-&gt;</span> _) <span class="o">=</span>
        <span class="i">s1</span><span class="o">.</span><span class="i">Zip</span>(<span class="i">s2</span>, <span class="k">new</span> <span class="i">Func</span><span class="o">&lt;</span>_,_,_<span class="o">&gt;</span>(<span class="i">resultSelector</span>))
</code></pre></td>
</tr>
</table>
<aside class="notes">
These are two custom operations introduced in F# 3.0 with the<br/>
query expressions. Note that we give the name in the `CustomOperationAttribute`.<br/>
The attribute accepts additional parameters, such as `AllowIntoPattern`,<br/>
`IsLikeZip`, etc. The full set of options is outside the scope of this talk,<br/>
but you can find them listed in the Microsoft docs online and in the full<br/>
implementation of the `RxQueryBuilder`.<br/>
The FSharp.Control.Reactive library made an interesting choice in providing<br/>
both the `observe` CE and the `rxquery` QE. There's no reason you cannot mix<br/>
the two in one builder. It turns out, you can also extend an existing builder<br/>
with new custom operations.<br/>
</aside>
</section>
<section >
<h3>Extending Existing Builders</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">FSharp</span><span class="o">.</span><span class="i">Control</span><span class="o">.</span><span class="i">AsyncBuilder</span> <span class="k">with</span>

    [&lt;<span class="i">CustomOperation</span>(<span class="s">&quot;and!&quot;</span>, <span class="i">IsLikeZip</span><span class="o">=</span><span class="k">true</span>)&gt;]
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Merge</span>(<span class="i">x</span>, <span class="i">y</span>,
                    [&lt;<span class="i">ProjectionParameter</span>&gt;] <span class="i">resultSelector</span> <span class="o">:</span> _ <span class="k">-&gt;</span> _) <span class="o">=</span>
        <span class="i">async</span> {
            <span class="k">let!</span> <span class="i">x&#39;</span> <span class="o">=</span> <span class="i">Async</span><span class="o">.</span><span class="i">StartChildAsTask</span> <span class="i">x</span>
            <span class="k">let!</span> <span class="i">y&#39;</span> <span class="o">=</span> <span class="i">Async</span><span class="o">.</span><span class="i">StartChildAsTask</span> <span class="i">y</span>
            <span class="k">do</span> <span class="i">Task</span><span class="o">.</span><span class="i">WaitAll</span>(<span class="i">x&#39;</span>,<span class="i">y&#39;</span>)
            <span class="k">let!</span> <span class="i">x&#39;&#39;</span> <span class="o">=</span> <span class="i">Async</span><span class="o">.</span><span class="i">AwaitTask</span> <span class="i">x&#39;</span>
            <span class="k">let!</span> <span class="i">y&#39;&#39;</span> <span class="o">=</span> <span class="i">Async</span><span class="o">.</span><span class="i">AwaitTask</span> <span class="i">y&#39;</span>
            <span class="k">return</span> <span class="i">resultSelector</span> <span class="i">x&#39;&#39;</span> <span class="i">y&#39;&#39;</span>
        }

    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">For</span>(<span class="i">m</span>, <span class="i">f</span>) <span class="o">=</span> <span class="i">__</span><span class="o">.</span><span class="i">Bind</span>(<span class="i">m</span>, <span class="i">f</span>)
</code></pre></td>
</tr>
</table>
<aside class="notes">
If you ever wished you could run two or more async computations in parallel<br/>
within an async computation expression, now you know you can by extending the<br/>
AsyncBuilder provided with FSharp.Core.<br/>
</aside>
</section>
<section >
<h3>Async Applicative Example</h3>
<aside class="notes">
Jump to VSCode to run this in FSI, as the code snippet is too long.<br/>
The code compares awaiting two sleeps and shows that the applicative,<br/>
which does not require awaiting the first value, can freely run in<br/>
parallel, whereas the monad version using `let!` must wait for each<br/>
in turn.<br/>
We could argue about the best syntax, but this version uses that proposed<br/>
in the VisualFSharp issues: https://github.com/fsharp/fslang-suggestions/issues/579<br/>
</aside>
</section>
<section >
<h3>Caveat emptor</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">FSharp</span><span class="o">.</span><span class="i">Control</span><span class="o">.</span><span class="i">AsyncBuilder</span> <span class="k">with</span>

    [&lt;<span class="i">CustomOperation</span>(<span class="s">&quot;and!&quot;</span>, <span class="i">IsLikeZip</span><span class="o">=</span><span class="k">true</span>)&gt;]
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Merge</span>(<span class="i">x</span><span class="o">:</span> <span class="i">Task</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span>, <span class="i">y</span><span class="o">:</span> <span class="i">Task</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>,
                    [&lt;<span class="i">ProjectionParameter</span>&gt;] <span class="i">resultSelector</span> <span class="o">:</span> _ <span class="k">-&gt;</span> _) <span class="o">=</span>
        <span class="i">async</span> {
            <span class="k">do</span> <span class="i">Task</span><span class="o">.</span><span class="i">WaitAll</span>(<span class="i">x</span>,<span class="i">y</span>)
            <span class="k">let!</span> <span class="i">x&#39;</span> <span class="o">=</span> <span class="i">Async</span><span class="o">.</span><span class="i">AwaitTask</span> <span class="i">x</span>
            <span class="k">let!</span> <span class="i">y&#39;</span> <span class="o">=</span> <span class="i">Async</span><span class="o">.</span><span class="i">AwaitTask</span> <span class="i">y</span>
            <span class="k">return</span> <span class="i">resultSelector</span> <span class="i">x&#39;</span> <span class="i">y&#39;</span>
        }
</code></pre></td>
</tr>
</table>
<aside class="notes">
You may assume that method overloading is as easy as adding another,<br/>
similar named method. After all, many people extend `AsyncBuilder`<br/>
with implementations of `Bind` that deal with `Task<'T>` and `Task`<br/>
so that they don't have to deal with the `Async.AwaitTask`.<br/>
Unfortunately, that's not allowed with custom operations. That is<br/>
to say, you can define the overload ...<br/>
</aside>
</section>
<section >
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">async</span> {
    <span class="k">for</span> <span class="i">x</span> <span class="k">in</span> <span class="i">Task</span><span class="o">.</span><span class="i">FromResult</span>(<span class="n">1</span>) <span class="k">do</span>
    <span class="i">``and!``</span> <span class="i">y</span> <span class="k">in</span> <span class="i">Task</span><span class="o">.</span><span class="i">FromResult</span>(<span class="n">2</span>)
    <span class="k">return</span> <span class="i">x</span> <span class="o">+</span> <span class="i">y</span>
}
</code></pre></td>
</tr>
</table>
<blockquote>
<p>The custom operation 'and!' refers to a method which is overloaded.
The implementations of custom operations may not be overloaded.<br />
custom operation: and! var in collection <br />
Calls AsyncBuilder.Merge</p>
</blockquote>
<aside class="notes">
But it will cause the custom operation to be unusable.<br/>
</aside>
</section>
<section >
<h3>Overloading workaround</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">module</span> <span class="i">Inference</span> <span class="o">=</span>
    <span class="k">type</span> <span class="i">Defaults</span> <span class="o">=</span>
        | <span class="i">Defaults</span>
        <span class="k">static</span> <span class="k">member</span> <span class="i">Value</span> (<span class="i">x</span><span class="o">:</span> <span class="i">Async</span><span class="o">&lt;</span><span class="i">int</span><span class="o">&gt;</span>) <span class="o">=</span>
            <span class="i">x</span>
        <span class="k">static</span> <span class="k">member</span> <span class="k">inline</span> <span class="i">Value</span> (<span class="i">x</span><span class="o">:</span> <span class="i">int</span>) <span class="o">=</span>
            <span class="i">async</span><span class="o">.</span><span class="i">Return</span> <span class="i">x</span>
        <span class="k">static</span> <span class="k">member</span> <span class="k">inline</span> <span class="i">Value</span> (<span class="i">x</span><span class="o">:</span> <span class="i">string</span>) <span class="o">=</span>
            <span class="i">int</span> <span class="i">x</span> <span class="o">|&gt;</span> <span class="i">async</span><span class="o">.</span><span class="i">Return</span>

    <span class="k">let</span> <span class="k">inline</span> <span class="i">defaults</span> (<span class="i">a</span><span class="o">:</span> <span class="o">^</span><span class="i">a</span>, _<span class="o">:</span> <span class="o">^</span><span class="i">b</span>) <span class="o">=</span>
        ((<span class="o">^</span><span class="i">a</span> <span class="k">or</span> <span class="o">^</span><span class="i">b</span>) <span class="o">:</span> (<span class="k">static</span> <span class="k">member</span> <span class="i">Value</span> <span class="o">:</span> <span class="o">^</span><span class="i">a</span> <span class="k">-&gt;</span> <span class="i">Async</span><span class="o">&lt;</span>_<span class="o">&gt;</span>) <span class="i">a</span>)
    
    <span class="k">let</span> <span class="k">inline</span> <span class="i">infer</span> (<span class="i">a</span><span class="o">:</span> <span class="o">&#39;</span><span class="i">a</span>) <span class="o">=</span>
        <span class="i">defaults</span>(<span class="i">a</span>, <span class="i">Defaults</span>)
</code></pre></td>
</tr>
</table>
<aside class="notes">
The Async Zip example is not really a good one. If you want to<br/>
allow both Async and Task<'T> in the same workflow, you're going to<br/>
have to ultimately pick one, and that usually means Task<'T>, which<br/>
changes the semantics of F# Async computations considerably. The<br/>
workaround should let you specify one of several types, typically<br/>
including a wrapped value, in this case, an Async<int>.<br/>
</aside>
</section>
<section >
<h3>Overloading workaround (cont)</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">FSharp</span><span class="o">.</span><span class="i">Control</span><span class="o">.</span><span class="i">AsyncBuilder</span> <span class="k">with</span>
    [&lt;<span class="i">CustomOperation</span>(<span class="s">&quot;add&quot;</span>, <span class="i">MaintainsVariableSpaceUsingBind</span><span class="o">=</span><span class="k">true</span>)&gt;]
    <span class="k">member</span> <span class="k">inline</span> <span class="i">__</span><span class="o">.</span><span class="i">Add</span>(<span class="i">m</span>, <span class="i">x</span>) <span class="o">=</span>
        <span class="i">async</span> {
            <span class="k">let!</span> <span class="i">a</span> <span class="o">=</span> <span class="i">m</span>
            <span class="k">let!</span> <span class="i">b</span> <span class="o">=</span> <span class="i">Inference</span><span class="o">.</span><span class="i">infer</span> <span class="i">x</span>
            <span class="k">return</span> <span class="i">a</span> <span class="o">+</span> <span class="i">b</span>
        }
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">async</span> {
    <span class="k">let!</span> <span class="i">m</span> <span class="o">=</span> <span class="i">async</span><span class="o">.</span><span class="i">Return</span> <span class="n">0</span>
    <span class="i">add</span> <span class="s">&quot;1&quot;</span>
    <span class="i">add</span> <span class="s">&quot;2&quot;</span>
} <span class="o">|&gt;</span> <span class="i">Async</span><span class="o">.</span><span class="i">RunSynchronously</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>3</code></pre></td></tr></table>
</section>
<section >
<h3>Other Limitations</h3>
<aside class="notes">
You can find additional limitations, specifically with query builders<br/>
in the error codes defined in FSharp.Core:<br/>
https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSComp.txt#L1206<br/>
</aside>
</section>
</section>
<section >
<section >
<h2>Three Rings for the Elven-kings under the sky</h2>
<p><a href="http://www.itsvery.net/lord-of-the-rings.html"><img src="images/elven-rings.jpg" alt="Elven kings" /></a></p>
<aside class="notes">
The rings of the elven kings were supposedly very powerful.<br/>
We've seens some interesting building blocks. It's time to<br/>
put everything together and find out what we can really do<br/>
with computation expressions.<br/>
Let's return to our motivation: to extend F#.<br/>
How might we accomplish this? We have seen we can extend the<br/>
available keywords by means of custom operations within computation<br/>
expressions, though we must remember we have to work within<br/>
certain constraints defined by the feature.<br/>
</aside>
</section>
<section >
<h3>Domain specific languages</h3>
<p>Implementations of Common Intermediate Language (CIL):</p>
<ul>
<li><a href="https://github.com/kbattocchi/ILBuilder">ILBuilder</a></li>
<li><a href="https://github.com/rspeele/LicenseToCIL">LicenseToCIL</a></li>
</ul>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">cil</span> {
    <span class="k">yield</span> <span class="i">ldc&#39;i4</span> <span class="n">1</span>
    <span class="k">yield</span> <span class="i">ldc&#39;i4</span> <span class="n">2</span>
    <span class="k">yield</span> <span class="i">add</span>
    <span class="k">yield</span> <span class="i">ldc&#39;i4</span> <span class="n">3</span>
    <span class="k">yield</span> <span class="i">add</span>
    <span class="k">yield</span> <span class="i">ret</span>
} <span class="o">|&gt;</span> <span class="i">toDelegate</span><span class="o">&lt;</span><span class="i">Func</span><span class="o">&lt;</span><span class="i">int</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="s">&quot;myFunction1&quot;</span>
</code></pre></td>
</tr>
</table>
<aside class="notes">
Everyone is familiar with the concept of domain specific<br/>
languages. Scott is going over this same topic in the<br/>
other room. So CEs can enable embedded domain specific<br/>
languages but are not necessary for that purpose.<br/>
</aside>
</section>
<section >
<h3>Protocols</h3>
<p><a href="https://freya.io/">Freya</a> implements the HTTP state machine</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">machine</span> <span class="o">=</span>
    <span class="i">freyaMachine</span> {
        <span class="i">methods</span> [<span class="i">GET</span>; <span class="i">HEAD</span>; <span class="i">OPTIONS</span>]
        <span class="i">handleOk</span> <span class="i">hello</span> }
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">router</span> <span class="o">=</span>
    <span class="i">freyaRouter</span> {
        <span class="i">resource</span> <span class="s">&quot;/hello{/name}&quot;</span> <span class="i">machine</span> }
</code></pre></td>
</tr>
</table>
<aside class="notes">
Protocols are another avenue we frequently ignore. HTTP<br/>
is an application protocol often dismissed as a transport<br/>
protocol. Both are protocols for networked communications.<br/>
In the case of HTTP, the server behavior is what's really<br/>
encoded. Clients may behave in almost any way they please.<br/>
TCP/IP, UDP, etc. are all protocols and define certain<br/>
characterisitcs of behavior.<br/>
</aside>
</section>
<section >
<h3>Session Types</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">module</span> <span class="i">example</span>;

<span class="k">type</span> <span class="o">&lt;</span><span class="i">xsd</span><span class="o">&gt;</span> <span class="s">&quot;{http://www.acme.com/types}Greetings&quot;</span> <span class="i">from</span> <span class="s">&quot;http://www.acme.com/types/Greetings.xsd&quot;</span> <span class="k">as</span> <span class="i">Greetings</span>;
<span class="k">type</span> <span class="o">&lt;</span><span class="i">xsd</span><span class="o">&gt;</span> <span class="s">&quot;{http://www.acme.com/types}Compliments&quot;</span> <span class="i">from</span> <span class="s">&quot;http://www.acme.com/types/Compliments.xsd&quot;</span> <span class="k">as</span> <span class="i">Compliments</span>;
<span class="k">type</span> <span class="o">&lt;</span><span class="i">xsd</span><span class="o">&gt;</span> <span class="s">&quot;{http://www.acme.com/types}Salutations&quot;</span> <span class="i">from</span> <span class="s">&quot;http://www.acme.com/types/Salutations.xsd&quot;</span> <span class="k">as</span> <span class="i">Salutations</span>;

<span class="k">global</span> <span class="i">protocol</span> <span class="i">HelloWorld</span>(<span class="i">role</span> <span class="i">Me</span>, <span class="i">role</span> <span class="i">World</span>) {
    <span class="i">hello</span>(<span class="i">Greetings</span>) <span class="i">from</span> <span class="i">Me</span> <span class="k">to</span> <span class="i">World</span>;
    <span class="i">choice</span> <span class="i">at</span> <span class="i">World</span> {
        <span class="i">goodMorning</span>(<span class="i">Compliments</span>) <span class="i">from</span> <span class="i">World</span> <span class="k">to</span> <span class="i">Me</span>;
    } <span class="k">or</span> {
        <span class="i">goodAfternoon</span>(<span class="i">Salutations</span>) <span class="i">from</span> <span class="i">World</span> <span class="k">to</span> <span class="i">Me</span>;
    }
}
</code></pre></td>
</tr>
</table>
<aside class="notes">
This leads us to Session Types.<br/>
Who has heard of session types?<br/>
Session types are under active research. The idea is to provide a<br/>
flexible type checking mechanism around protocols covering multiple<br/>
parties. HTTP is an application protocol but only stipulates server<br/>
behavior. Session types aim to cover multiple clients, including actors.<br/>
Consider how Type Providers made accessing data sources almost trivial<br/>
(at least once you had the type provider). Session types could<br/>
provide type safety on various types of workflows across multiple<br/>
agents.<br/>
This is an example of Scribble, a language for defining protocols<br/>
for use with session types. I think we could encode Scribble<br/>
as a computation expression and provide session types within<br/>
F#.<br/>
</aside>
</section>
<section >
<h3>How?</h3>
<aside class="notes">
This is all well and good, but how would you do something like<br/>
this?<br/>
The trick is thinking beyond the obvious. The obvious thing<br/>
to do, and the trap that the monad path leads you, is to think<br/>
of computation expressions as providing computations around<br/>
a specific data type or data structure, e.g. Async, Seq, Option,<br/>
etc.<br/>
However, you don't have to limit yourself to the visible type.<br/>
Async works this way. There are many types that make up Async<br/>
workflows. Query Expressions, too, hide a lot more than we<br/>
saw earlier.<br/>
</aside>
</section>
<section >
<h3>Query Expressions Revisited</h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">xn</span> <span class="i">s</span> <span class="o">=</span> <span class="i">XName</span><span class="o">.</span><span class="i">Get</span> <span class="i">s</span>
<span class="k">let</span> <span class="i">xml</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;&lt;people&gt;</span>
<span class="s">    &lt;person firstName=&quot;Mathias&quot; lastName=&quot;Brandewinder&quot; /&gt;</span>
<span class="s">    &lt;person firstName=&quot;Andrew&quot; lastName=&quot;Cherry&quot; /&gt;</span>
<span class="s">    &lt;person firstName=&quot;&quot; lastName=&quot;Riley&quot; /&gt;</span>
<span class="s">&lt;/people&gt;&quot;&quot;&quot;</span>
<span class="k">let</span> <span class="i">doc</span> <span class="o">=</span> <span class="i">XDocument</span><span class="o">.</span><span class="i">Parse</span> <span class="i">xml</span>
<span class="i">query</span> {
    <span class="k">for</span> <span class="i">el</span> <span class="k">in</span> <span class="i">doc</span><span class="o">.</span><span class="i">Descendants</span>(<span class="i">xn</span> <span class="s">&quot;person&quot;</span>) <span class="k">do</span>
    <span class="i">where</span> (<span class="i">el</span><span class="o">.</span><span class="i">Attribute</span>(<span class="i">xn</span> <span class="s">&quot;firstName&quot;</span>)<span class="o">.</span><span class="i">Value</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;&quot;</span>)
    <span class="i">select</span> (<span class="i">el</span><span class="o">.</span><span class="i">Attribute</span>(<span class="i">xn</span> <span class="s">&quot;lastName&quot;</span>)<span class="o">.</span><span class="i">Value</span>)
}
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>seq ["Brandewinder"; "Cherry"]</code></pre></td></tr></table>
<aside class="notes">
F#'s query expressions appear to work with Seq<'T>, but<br/>
actually works with expressions and is intended to be used<br/>
with LINQ queries.<br/>
The most obvious example would be working with a database,<br/>
and you can find an example of this in the Microsoft docs.<br/>
Here we look at an example using an XDocument, which also<br/>
uses LINQ.<br/>
While the built-in query expression works just fine with<br/>
Seq<'T>, it is clearly doing more under the covers.<br/>
</aside>
</section>
<section >
<h3>Freya's Graph</h3>
<p><img src="images/http-state-diagram.png" alt="HTTP state diagram" /></p>
<aside class="notes">
Freya does something similar. It wraps a bit of state behind<br/>
it's computation and then uses a graph model to facilitate<br/>
the request/response state machine of HTTP. It exposes hooks<br/>
to tap into the state machine, rather than having programmers<br/>
specify exactly how to process each request. Freya goes even<br/>
further in allowing programmers to compose the graph itself<br/>
with the `using` expression.<br/>
</aside>
</section>
<section >
<img alt="Freya's core components" src="images/freya/components.core.png" width="40%" />
<aside class="notes">
Freya hides a graph of components that are used to run the<br/>
application once configured.<br/>
</aside>
</section>
<section >
<img alt="Freya's responses" src="images/freya/specifications.responses.png" width="60%" />
<aside class="notes">
The graph is composed of smaller graphs.<br/>
</aside>
</section>
<section >
<p><img src="images/freya/specifications.validations.png" alt="Freya's validations" /></p>
<aside class="notes">
Each exposes functionality that can be tapped into.<br/>
This is the goal of declarative programming, after all:<br/>
specify the what, not the how.<br/>
The point is to remind you to think beyond the immediate data<br/>
structure. I don't think we've reached the limit to what we<br/>
can achieve with computation expressions.<br/>
</aside>
</section>
</section>
<section >
<h2>Questions?</h2>
</section>
<section >
<section >
<h2>Why Not Macros?</h2>
<aside class="notes">
Since we are talking about language extensions, we must first<br/>
talk about macros. After all, languages in the Lisp family<br/>
support macros, to the extent that much of the language is built<br/>
in macros. What could be more powerful? In short, nothing.<br/>
However, F# does not provide a mechanism for writing macros,<br/>
and it's a fair question to ask, "Why not?"<br/>
Macros require a pre-compiler or a compiler plugin mechanism.<br/>
When you introduce something like this, you are either on<br/>
some other tool to handle some of the work of compiling a program.<br/>
This can drastically increase and complicate compile times or even<br/>
create very difficult-to-debug compiler crashes.<br/>
In addition, macros don't play very well with typed languages<br/>
as you are essentially relying on something typed to rely on<br/>
something untyped-until-generated.<br/>
Type Providers are the closest thing F# has to macros, but these<br/>
only provide types and don't extend the language.<br/>
Computation expressions don't carry the full power of macros,<br/>
but they cover the most important use cases to the point you won't<br/>
likely miss macros.<br/>
</aside>
</section>
<section >
<h3>Research</h3>
<h4><a href="https://www.cs.indiana.edu/~sabry/papers/macroml.pdf">MacroML</a></h4>
<h4><a href="https://pdfs.semanticscholar.org/339f/4370bd02b977fc0d61fca50cc6a0ea26a24b.pdf">MetaML</a></h4>
<aside class="notes">
Despite the challenges of implementing macros with statically typed<br/>
languages, several research efforts are making progress. Follow the<br/>
links to read more.<br/>
</aside>
</section>
</section>
<section >
<h2>Will F# ever get Type Classes?</h2>
<h3><a href="https://github.com/MattoWindsor91/visualfsharp/blob/hackathon-vs/examples/fsconcepts.md">Classes for the Masses</a></h3>
<aside class="notes">
Incidentally, type classes, which Haskell uses to encode monads and other<br/>
container types, have a proven encoding in F# and may be coming in a future<br/>
release. Hopefully this will alleviate some of the pit of computation-<br/>
expressions-as-monad-encodings that many fall into.<br/>
</aside>
</section>
<section >
<h2>References</h2>
<ol>
<li><a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions">Computation Expressions</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/query-expressions">Query Expressions</a></li>
<li><a href="https://vimeo.com/47218436">Computation Expresssions in F# 3.0</a></li>
<li><a href="https://blogs.msdn.microsoft.com/dsyme/2007/10/10/introducing-f-asynchronous-workflows/">Introducing F# Asynchronous Workflows</a></li>
<li><a href="http://tomasp.net/academic/papers/computation-zoo/computation-zoo.pdf">The F# Computation Expression Zoo</a></li>
<li><a href="https://fsharpforfunandprofit.com/series/computation-expressions.html">F# for fun and profit</a></li>
<li><a href="https://github.com/fsharp/fslang-suggestions/issues/579">Support let! .. and... for applicative functors</a></li>
</ol>
</section>
<section >
</section>


        </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script>
        // Add the nohighlight class and data-noescape attribute to code elements that have already been formatted by FSharp.Formatting
        $('pre.highlighted code').addClass('nohighlight').attr('data-noescape', '');

        // Full list of configuration options available here:
        // https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            controls: true,
            progress: true,
            history: true,
            center: true,

            transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

            // Parallax scrolling
            // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
            // parallaxBackgroundSize: '2100px 900px',

            // Optional libraries used to extend on reveal.js
            dependencies: [
                { src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
                { src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
                { src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
                { src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
                { src: 'plugin/zoom-js/zoom.js', async: true, condition: function () { return !!document.body.classList; } },
                { src: 'plugin/notes/notes.js', async: true, condition: function () { return !!document.body.classList; } }
            ]
        });

    </script>
</body>
</html>

